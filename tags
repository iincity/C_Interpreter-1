!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADD	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
ADDEQUAL	parser.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:__anon1
ALPHABET_SIZE	c_utils.c	526;"	d	file:
BASIC_TYPES	basic_types.h	2;"	d
BINARY_OP	interpreter.h	87;"	d
BINARY_OP1	tests/types.c	3;"	d	file:
BOTH	parser.h	/^	BOTH$/;"	e	enum:__anon6
BREAK	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
BREAK_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon5
CASE	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
CASE_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon5
CHAR	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
CHAR_LITERAL	parser.h	/^	INT_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:__anon1
CHAR_TYPE	parser.h	/^	CHAR_TYPE, \/* implementation defined whether plain char is signed or not ...*\/$/;"	e	enum:__anon2
CLEAR_SCREEN	c_utils.h	71;"	d
CLIST_H	clist.h	2;"	d
COLON	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
COMMA	parser.h	/^	EQUAL='=', COMMA=',', LBRACKET='[', RBRACKET=']', LBRACE='{', RBRACE='}', TERNARY,$/;"	e	enum:__anon1
COND_EXPR	interpreter.h	139;"	d
CONTINUE	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
CONTINUE_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon5
CVECTOR_H	cvector.h	4;"	d
CVECTOR_IMPLEMENTATION	parser.c	5;"	d	file:
C_UTILS	c_utils.h	2;"	d
DECLARATION	parser.h	/^	LABEL, DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:__anon1
DECL_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon5
DECREMENT	parser.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:__anon1
DEFAULT	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
DEFAULT_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon5
DIV	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
DIVEQUAL	parser.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:__anon1
DO	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
DOUBLE	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
DOUBLE_TYPE	parser.h	/^	DOUBLE_TYPE,$/;"	e	enum:__anon2
DO_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon5
ELSE	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
END	parser.h	/^	ERROR, END,$/;"	e	enum:__anon1
END_COMPOUND_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon5
EQUAL	parser.h	/^	EQUAL='=', COMMA=',', LBRACKET='[', RBRACKET=']', LBRACE='{', RBRACE='}', TERNARY,$/;"	e	enum:__anon1
EQUALEQUAL	parser.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:__anon1
ERROR	parser.h	/^	ERROR, END,$/;"	e	enum:__anon1
EXP	parser.h	/^	LABEL, DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:__anon1
EXPR_LIST	parser.h	/^	LABEL, DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:__anon1
EXPR_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon5
FLOAT	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
FLOAT_LITERAL	parser.h	/^	INT_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:__anon1
FLOAT_TYPE	parser.h	/^	FLOAT_TYPE,$/;"	e	enum:__anon2
FOR	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
FOR_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon5
FUNCTION_TYPE	parser.h	/^	FUNCTION_TYPE,$/;"	e	enum:__anon2
FUNC_CALL	parser.h	/^	LABEL, DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:__anon1
GET_BINDING	parser.h	20;"	d
GET_FUNCTION	parser.h	18;"	d
GET_STMT	parser.h	16;"	d
GET_SYMBOL	parser.h	19;"	d
GET_TOKEN_VAL	parser.h	17;"	d
GET_VAR_VALUE	parser.h	103;"	d
GET_VOID	cvector.h	135;"	d
GOTO	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
GOTO_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon5
GREATER	parser.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:__anon1
GTEQ	parser.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:__anon1
ID	parser.h	/^	ID,$/;"	e	enum:__anon1
IF	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
IF_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon5
INCREMENT	parser.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:__anon1
INIT_LIST_HEAD	clist.h	/^static inline void INIT_LIST_HEAD(list_head *list)$/;"	f	signature:(list_head *list)
INIT_STATEMENT	parser.h	188;"	d
INT	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
INTEGRAL_BINARY_OP	interpreter.h	123;"	d
INTERPRETER_H	interpreter.h	2;"	d
INT_LITERAL	parser.h	/^	INT_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:__anon1
INT_PTR_TYPE	parser.h	/^	INT_PTR_TYPE$/;"	e	enum:__anon2
INT_TYPE	parser.h	/^	INT_TYPE,$/;"	e	enum:__anon2
LABEL	parser.h	/^	LABEL, DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:__anon1
LBRACE	parser.h	/^	EQUAL='=', COMMA=',', LBRACKET='[', RBRACKET=']', LBRACE='{', RBRACE='}', TERNARY,$/;"	e	enum:__anon1
LBRACKET	parser.h	/^	EQUAL='=', COMMA=',', LBRACKET='[', RBRACKET=']', LBRACE='{', RBRACE='}', TERNARY,$/;"	e	enum:__anon1
LESS	parser.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:__anon1
LIST_HEAD	clist.h	13;"	d
LIST_HEAD_INIT	clist.h	11;"	d
LOGICAL_AND	parser.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:__anon1
LOGICAL_NEGATION	parser.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:__anon1
LOGICAL_OR	parser.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:__anon1
LONG	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
LONG_TYPE	parser.h	/^	LONG_TYPE,$/;"	e	enum:__anon2
LPAREN	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
LTEQ	parser.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:__anon1
MAX_TOKEN_LEN	parser.h	14;"	d
MOD	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
MODEQUAL	parser.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:__anon1
MULT	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
MULTEQUAL	parser.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:__anon1
MYCOMMA	interpreter.c	267;"	d	file:
MYCOMMA	interpreter.c	269;"	d	file:
MYCOMMA	interpreter.c	403;"	d	file:
MYCOMMA	interpreter.c	405;"	d	file:
MYCOMMA	tests/types.c	5;"	d	file:
NOTEQUAL	parser.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:__anon1
NULL_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon5
ONLY_GLOBAL	parser.h	/^	ONLY_GLOBAL,$/;"	e	enum:__anon6
ONLY_LOCAL	parser.h	/^	ONLY_LOCAL,$/;"	e	enum:__anon6
PARSER_H	parser.h	2;"	d
POST_DECREMENT	parser.h	/^	POST_INCREMENT, POST_DECREMENT, PRE_INCREMENT, PRE_DECREMENT$/;"	e	enum:__anon1
POST_INCREMENT	parser.h	/^	POST_INCREMENT, POST_DECREMENT, PRE_INCREMENT, PRE_DECREMENT$/;"	e	enum:__anon1
POST_OP	interpreter.h	77;"	d
PRE_DECREMENT	parser.h	/^	POST_INCREMENT, POST_DECREMENT, PRE_INCREMENT, PRE_DECREMENT$/;"	e	enum:__anon1
PRE_INCREMENT	parser.h	/^	POST_INCREMENT, POST_DECREMENT, PRE_INCREMENT, PRE_DECREMENT$/;"	e	enum:__anon1
PRE_OP	interpreter.h	68;"	d
PRE_OP	tests/types.c	61;"	d	file:
PRINT	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
PRINT_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon5
PROJECTS	build/Makefile	/^PROJECTS := cinterpreter$/;"	m
RBRACE	parser.h	/^	EQUAL='=', COMMA=',', LBRACKET='[', RBRACKET=']', LBRACE='{', RBRACE='}', TERNARY,$/;"	e	enum:__anon1
RBRACKET	parser.h	/^	EQUAL='=', COMMA=',', LBRACKET='[', RBRACKET=']', LBRACE='{', RBRACE='}', TERNARY,$/;"	e	enum:__anon1
READ_STRING	c_utils.h	50;"	d
RETURN	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
RETURN_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon5
RPAREN	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
SEMICOLON	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
SET_C_ARRAY	c_utils.h	18;"	d
SHORT	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
SHORT_TYPE	parser.h	/^	SHORT_TYPE,$/;"	e	enum:__anon2
SIGNED	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
SINT_TYPE	parser.h	/^	SINT_TYPE,$/;"	e	enum:__anon2
SORT_COLUMN_INDEX	stats/sortable.js	/^var SORT_COLUMN_INDEX;$/;"	v
SPACE_SET	c_utils.h	75;"	d
SPACE_SET_NO_NEWLINE	c_utils.h	76;"	d
START_COMPOUND_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon5
STDERR	vector_binding.c	5;"	d	file:
STDERR	vector_template.c	5;"	d	file:
STR_LITERAL	parser.h	/^	INT_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:__anon1
SUB	parser.h	/^	MOD='%', LPAREN='(', RPAREN=')', MULT='*', ADD='+', SUB='-', DIV='\/', COLON=':', SEMICOLON=';',$/;"	e	enum:__anon1
SUBEQUAL	parser.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:__anon1
SWITCH	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
SWITCH_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon5
TERNARY	parser.h	/^	EQUAL='=', COMMA=',', LBRACKET='[', RBRACKET=']', LBRACE='{', RBRACE='}', TERNARY,$/;"	e	enum:__anon1
Token	parser.h	/^} Token;$/;"	t	typeref:enum:__anon1
UCHAR_TYPE	parser.h	/^	UCHAR_TYPE,$/;"	e	enum:__anon2
ULONG_TYPE	parser.h	/^	ULONG_TYPE,$/;"	e	enum:__anon2
UNKNOWN	parser.h	/^	UNKNOWN = 0,$/;"	e	enum:__anon2
UNSIGNED	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
USHORT_TYPE	parser.h	/^	USHORT_TYPE,$/;"	e	enum:__anon2
VECTOR_TYPE_H	vector_template.h	2;"	d
VECTOR_TYPE_SZ	vector_template.c	/^size_t VECTOR_TYPE_SZ = 50;$/;"	v
VECTOR_binding_H	vector_binding.h	2;"	d
VECTOR_binding_SZ	vector_binding.c	/^size_t VECTOR_binding_SZ = 50;$/;"	v
VEC_D_ALLOCATOR	cvector.h	422;"	d
VEC_D_START_SZ	cvector.h	/^size_t VEC_D_START_SZ = 50;$/;"	v
VEC_I_ALLOCATOR	cvector.h	172;"	d
VEC_I_START_SZ	cvector.h	/^size_t VEC_I_START_SZ = 50;$/;"	v
VEC_START_SZ	cvector.h	/^size_t VEC_START_SZ = 20;$/;"	v
VEC_STR_ALLOCATOR	cvector.h	671;"	d
VEC_STR_START_SZ	cvector.h	/^size_t VEC_STR_START_SZ = 20;$/;"	v
VEC_TYPE_ALLOCATOR	vector_template.c	7;"	d	file:
VEC_VOID_ALLOCATOR	cvector.h	991;"	d
VEC_binding_ALLOCATOR	vector_binding.c	7;"	d	file:
VOID	parser.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:__anon1
VOID_TYPE	parser.h	/^	VOID_TYPE,$/;"	e	enum:__anon2
WHILE	parser.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:__anon1
WHILE_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon5
__list_add	clist.h	/^static inline void __list_add(list_head* item, list_head* prev, list_head* next)$/;"	f	signature:(list_head* item, list_head* prev, list_head* next)
__list_del	clist.h	/^static inline void __list_del(list_head* prev, list_head* next)$/;"	f	signature:(list_head* prev, list_head* next)
__list_for_each	clist.h	130;"	d
a	cvector.h	/^	char** a;          \/**< Array. *\/$/;"	m	struct:vector_str	access:public
a	cvector.h	/^	double* a;         \/**< Array. *\/$/;"	m	struct:vector_d	access:public
a	cvector.h	/^	int* a;            \/**< Array. *\/$/;"	m	struct:vector_i	access:public
a	cvector.h	/^	u8* a;                 \/**< Array. *\/$/;"	m	struct:vector_void	access:public
a	tests/declarations.c	/^int a=0, b=0, c=10;$/;"	v
a	tests/functions.c	/^int a = 1;$/;"	v
a	tests/ifelse.c	/^int a = 1;$/;"	v
a	tests/scope.c	/^int a = 10 % 3, b = 13 * 12 + 2, c = 10;$/;"	v
a	vector_binding.h	/^	binding* a;           \/**< Array. *\/$/;"	m	struct:vector_binding	access:public
a	vector_template.h	/^	TYPE* a;           \/**< Array. *\/$/;"	m	struct:vector_TYPE	access:public
a_case	parser.h	/^typedef struct a_case$/;"	s
a_case	parser.h	/^} a_case;$/;"	t	typeref:struct:a_case
a_case::jump_to	parser.h	/^	unsigned int jump_to;$/;"	m	struct:a_case	access:public
a_case::val	parser.h	/^	int val;$/;"	m	struct:a_case	access:public
active_binding	parser.h	/^typedef struct active_binding$/;"	s
active_binding	parser.h	/^} active_binding;$/;"	t	typeref:struct:active_binding
active_binding::list	parser.h	/^	list_head list;$/;"	m	struct:active_binding	access:public
active_binding::parent	parser.h	/^	int parent;$/;"	m	struct:active_binding	access:public
active_binding::val	parser.h	/^	var_value val;$/;"	m	struct:active_binding	access:public
addEvent	stats/sortable.js	/^function addEvent(elm, evType, fn, useCapture)$/;"	f
add_binding	interpreter.c	/^void add_binding(program_state* prog, char* name, var_type vtype)$/;"	f	signature:(program_state* prog, char* name, var_type vtype)
add_binding	interpreter.h	/^void add_binding(program_state* prog, char* name, var_type vtype);$/;"	p	signature:(program_state* prog, char* name, var_type vtype)
add_binding	parser.h	/^void add_binding(program_state* prog, char* name, var_type vtype);$/;"	p	signature:(program_state* prog, char* name, var_type vtype)
add_expr	parser.c	/^void add_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
add_expr	parser.h	/^void add_expr(parsing_state* p, program_state* prog, expression* exp);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* exp)
all	c_utils.c	/^int all(c_array* array, int (*is_true)(const void*))$/;"	f	signature:(c_array* array, int (*is_true)(const void*))
all	c_utils.h	/^int all(c_array* array, int (*is_true)(const void*));$/;"	p	signature:(c_array* array, int (*is_true)(const void*))
alternate	stats/sortable.js	/^function alternate(table) {$/;"	f
alternate_row_colors	stats/sortable.js	/^var alternate_row_colors = true;$/;"	v
any	c_utils.c	/^int any(c_array* array, int (*is_true)(const void*))$/;"	f	signature:(c_array* array, int (*is_true)(const void*))
any	c_utils.h	/^int any(c_array* array, int (*is_true)(const void*));$/;"	p	signature:(c_array* array, int (*is_true)(const void*))
apply_scope	interpreter.c	/^void apply_scope(program_state* prog, int jump_to, int child, int parent)$/;"	f	signature:(program_state* prog, int jump_to, int child, int parent)
apply_scope	interpreter.h	/^void apply_scope(program_state* prog, int jump_to, int child, int parent);$/;"	p	signature:(program_state* prog, int jump_to, int child, int parent)
apply_scope	parser.h	/^void apply_scope(program_state* prog, int jump_to, int child, int parent);$/;"	p	signature:(program_state* prog, int jump_to, int child, int parent)
are_equal_char	c_utils.c	/^int are_equal_char(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_char	c_utils.h	/^int are_equal_char(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_double	c_utils.c	/^int are_equal_double(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_double	c_utils.h	/^int are_equal_double(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_float	c_utils.c	/^int are_equal_float(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_float	c_utils.h	/^int are_equal_float(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_int	c_utils.c	/^int are_equal_int(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_int	c_utils.h	/^int are_equal_int(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_long	c_utils.c	/^int are_equal_long(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_long	c_utils.h	/^int are_equal_long(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_short	c_utils.c	/^int are_equal_short(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_short	c_utils.h	/^int are_equal_short(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_uchar	c_utils.c	/^int are_equal_uchar(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_uchar	c_utils.h	/^int are_equal_uchar(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_uint	c_utils.c	/^int are_equal_uint(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_uint	c_utils.h	/^int are_equal_uint(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_ulong	c_utils.c	/^int are_equal_ulong(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_ulong	c_utils.h	/^int are_equal_ulong(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_ushort	c_utils.c	/^int are_equal_ushort(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_ushort	c_utils.h	/^int are_equal_ushort(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
assign_expr	parser.c	/^void assign_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
assign_expr	parser.h	/^void assign_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
assignment_operator	parser.c	/^int assignment_operator(Token tok)$/;"	f	signature:(Token tok)
author_of_month	stats/authors.html	/^<h2><a href="#author_of_month" name="author_of_month">Author of Month<\/a><\/h2>$/;"	a
author_of_year	stats/authors.html	/^<h2><a href="#author_of_year" name="author_of_year">Author of Year<\/a><\/h2>$/;"	a
b	tests/declarations.c	/^int a=0, b=0, c=10;$/;"	v
b	tests/scope.c	/^int a = 10 % 3, b = 13 * 12 + 2, c = 10;$/;"	v
back_TYPE	vector_template.c	/^TYPE* back_TYPE(vector_TYPE* vec)$/;"	f	signature:(vector_TYPE* vec)
back_TYPE	vector_template.h	/^TYPE* back_TYPE(vector_TYPE* vec);$/;"	p	signature:(vector_TYPE* vec)
back_binding	vector_binding.c	/^binding* back_binding(vector_binding* vec)$/;"	f	signature:(vector_binding* vec)
back_binding	vector_binding.h	/^binding* back_binding(vector_binding* vec);$/;"	p	signature:(vector_binding* vec)
back_d	cvector.h	/^double* back_d(vector_d* vec)$/;"	f	signature:(vector_d* vec)
back_d	cvector.h	/^double* back_d(vector_d* vec);$/;"	p	signature:(vector_d* vec)
back_i	cvector.h	/^int* back_i(vector_i* vec)$/;"	f	signature:(vector_i* vec)
back_i	cvector.h	/^int* back_i(vector_i* vec);$/;"	p	signature:(vector_i* vec)
back_str	cvector.h	/^char** back_str(vector_str* vec)$/;"	f	signature:(vector_str* vec)
back_str	cvector.h	/^char** back_str(vector_str* vec);$/;"	p	signature:(vector_str* vec)
back_void	cvector.h	/^void* back_void(vector_void* vec)$/;"	f	signature:(vector_void* vec)
back_void	cvector.h	/^void* back_void(vector_void* vec);$/;"	p	signature:(vector_void* vec)
basic_search	c_utils.c	/^void basic_search(c_array haystack, c_array needle)$/;"	f	signature:(c_array haystack, c_array needle)
basic_search	c_utils.h	/^void basic_search(c_array haystack, c_array needle);$/;"	p	signature:(c_array haystack, c_array needle)
binding	parser.h	/^typedef struct binding$/;"	s
binding	parser.h	/^} binding;$/;"	t	typeref:struct:binding
binding::decl_stmt	parser.h	/^	int decl_stmt;$/;"	m	struct:binding	access:public
binding::name	parser.h	/^	char* name;$/;"	m	struct:binding	access:public
binding::vtype	parser.h	/^	var_type vtype;$/;"	m	struct:binding	access:public
bindings	parser.h	/^	vector_void* bindings;$/;"	m	struct:program_state	access:public
bindings	parser.h	/^	vector_void* bindings;$/;"	m	struct:statement	access:public
blah	tests/experimenting.c	/^int blah = 25;$/;"	v
blah2	tests/experimenting.c	/^int blah2 = 50;$/;"	v
boyermoore_search	c_utils.c	/^void boyermoore_search(c_array haystack_array, c_array needle_array)$/;"	f	signature:(c_array haystack_array, c_array needle_array)
boyermoore_search	c_utils.h	/^void boyermoore_search(c_array haystack_array, c_array needle_array);$/;"	p	signature:(c_array haystack_array, c_array needle_array)
break_or_continue_stmt	parser.c	/^void break_or_continue_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
break_or_continue_stmt	parser.h	/^void break_or_continue_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
byte	basic_types.h	/^typedef unsigned char byte;$/;"	t
c	tests/declarations.c	/^int a=0, b=0, c=10;$/;"	v
c	tests/experimenting.c	/^int c = 15;$/;"	v
c	tests/scope.c	/^int a = 10 % 3, b = 13 * 12 + 2, c = 10;$/;"	v
c_array	c_utils.h	/^typedef struct c_array$/;"	s
c_array	c_utils.h	/^} c_array;$/;"	t	typeref:struct:c_array
c_array::data	c_utils.h	/^	byte* data;$/;"	m	struct:c_array	access:public
c_array::elem_size	c_utils.h	/^	size_t elem_size;$/;"	m	struct:c_array	access:public
c_array::len	c_utils.h	/^	size_t len;$/;"	m	struct:c_array	access:public
c_out	generate_code.py	/^c_out = cfile_string.replace('TYPE', gen_type);$/;"	v
capacity	cvector.h	/^	size_t capacity;         \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_void	access:public
capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_d	access:public
capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_i	access:public
capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_str	access:public
capacity	vector_binding.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_binding	access:public
capacity	vector_template.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_TYPE	access:public
case_or_default_stmt	parser.c	/^void case_or_default_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
case_or_default_stmt	parser.h	/^void case_or_default_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
case_val	parser.h	/^	int case_val;$/;"	m	struct:statement	access:public
cfile_string	generate_code.py	/^cfile_string = open("vector_template.c").read();$/;"	v
char_val	parser.h	/^		char char_val;$/;"	m	union:var_value::__anon3	access:public
clean_num	stats/sortable.js	/^function clean_num(str) {$/;"	f
clear_TYPE	vector_template.c	/^void clear_TYPE(vector_TYPE* vec) { vec->size = 0; }$/;"	f	signature:(vector_TYPE* vec)
clear_TYPE	vector_template.h	/^void clear_TYPE(vector_TYPE* vec);$/;"	p	signature:(vector_TYPE* vec)
clear_binding	vector_binding.c	/^void clear_binding(vector_binding* vec) { vec->size = 0; }$/;"	f	signature:(vector_binding* vec)
clear_binding	vector_binding.h	/^void clear_binding(vector_binding* vec);$/;"	p	signature:(vector_binding* vec)
clear_bindings	interpreter.c	/^void clear_bindings(program_state* prog)$/;"	f	signature:(program_state* prog)
clear_bindings	interpreter.h	/^void clear_bindings(program_state* prog);$/;"	p	signature:(program_state* prog)
clear_bindings	parser.h	/^void clear_bindings(program_state* prog);$/;"	p	signature:(program_state* prog)
clear_d	cvector.h	/^void clear_d(vector_d* vec) { vec->size = 0; }$/;"	f	signature:(vector_d* vec)
clear_d	cvector.h	/^void clear_d(vector_d* vec);$/;"	p	signature:(vector_d* vec)
clear_i	cvector.h	/^void clear_i(vector_i* vec) { vec->size = 0; }$/;"	f	signature:(vector_i* vec)
clear_i	cvector.h	/^void clear_i(vector_i* vec);$/;"	p	signature:(vector_i* vec)
clear_str	cvector.h	/^void clear_str(vector_str* vec)$/;"	f	signature:(vector_str* vec)
clear_str	cvector.h	/^void clear_str(vector_str* vec);$/;"	p	signature:(vector_str* vec)
clear_void	cvector.h	/^void clear_void(vector_void* vec)$/;"	f	signature:(vector_void* vec)
clear_void	cvector.h	/^void clear_void(vector_void* vec);$/;"	p	signature:(vector_void* vec)
comma_expr	parser.c	/^void comma_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
comma_expr	parser.h	/^void comma_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
commits_by_domains	stats/authors.html	/^<h2><a href="#commits_by_domains" name="commits_by_domains">Commits by Domains<\/a><\/h2>$/;"	a
commits_by_timezone	stats/activity.html	/^<h2><a href="#commits_by_timezone" name="commits_by_timezone">Commits by Timezone<\/a><\/h2>$/;"	a
commits_by_year	stats/activity.html	/^<h2><a href="#commits_by_year" name="commits_by_year">Commits by Year<\/a><\/h2>$/;"	a
commits_by_year/month	stats/activity.html	/^<h2><a href="#commits_by_year\/month" name="commits_by_year\/month">Commits by year\/month<\/a><\/h2>$/;"	a
commits_per_author	stats/authors.html	/^<h2><a href="#commits_per_author" name="commits_per_author">Commits per Author<\/a><\/h2>$/;"	a
compare_char	c_utils.c	/^int compare_char(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_char	c_utils.h	/^int compare_char(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_double	c_utils.c	/^int compare_double(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_double	c_utils.h	/^int compare_double(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_float	c_utils.c	/^int compare_float(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_float	c_utils.h	/^int compare_float(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_int	c_utils.c	/^int compare_int(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_int	c_utils.h	/^int compare_int(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_long	c_utils.c	/^int compare_long(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_long	c_utils.h	/^int compare_long(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_numeric	stats/sortable.js	/^function compare_numeric(a,b) {$/;"	f
compare_short	c_utils.c	/^int compare_short(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_short	c_utils.h	/^int compare_short(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_uchar	c_utils.c	/^int compare_uchar(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_uchar	c_utils.h	/^int compare_uchar(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_uint	c_utils.c	/^int compare_uint(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_uint	c_utils.h	/^int compare_uint(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_ulong	c_utils.c	/^int compare_ulong(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_ulong	c_utils.h	/^int compare_ulong(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_ushort	c_utils.c	/^int compare_ushort(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_ushort	c_utils.h	/^int compare_ushort(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compound_statement	parser.c	/^void compound_statement(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
compound_statement	parser.h	/^void compound_statement(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
compute_prefix_func	c_utils.c	/^unsigned int * compute_prefix_func(byte *p, size_t len)$/;"	f	signature:(byte *p, size_t len)
cond_expr	parser.c	/^void cond_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
cond_expr	parser.h	/^void cond_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
config	build/Makefile	/^  config=debug$/;"	m
container_of	clist.h	81;"	d
copy_c_array	c_utils.c	/^c_array copy_c_array(c_array src)$/;"	f	signature:(c_array src)
copy_c_array	c_utils.h	/^c_array copy_c_array(c_array src);$/;"	p	signature:(c_array src)
copy_expr	parser.c	/^expression* copy_expr(program_state* prog, expression* e)$/;"	f	signature:(program_state* prog, expression* e)
copy_expr	parser.h	/^expression* copy_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
cumulated_added_lines_of_code_per_author	stats/authors.html	/^<h2><a href="#cumulated_added_lines_of_code_per_author" name="cumulated_added_lines_of_code_per_author">Cumulated Added Lines of Code per Author<\/a><\/h2>$/;"	a
cur_iter	parser.h	/^	int cur_iter;$/;"	m	struct:program_state	access:public
cur_iter_switch	parser.h	/^	int cur_iter_switch;$/;"	m	struct:program_state	access:public
cur_parent	parser.h	/^	int cur_parent; \/\/<-- location of open block statement$/;"	m	struct:program_state	access:public
cur_parent	parser.h	/^	int cur_parent;$/;"	m	struct:symbol	access:public
data	c_utils.h	/^	byte* data;$/;"	m	struct:c_array	access:public
data	clist.h	/^	int data;$/;"	m	struct:int_list	access:public
data	parser.h	/^	expression* data;$/;"	m	struct:expr_block	access:public
day_of_week	stats/activity.html	/^<h2><a href="#day_of_week" name="day_of_week">Day of Week<\/a><\/h2>$/;"	a
decl_stmt	parser.h	/^	int decl_stmt;$/;"	m	struct:binding	access:public
declaration	parser.c	/^void declaration(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
declaration	parser.h	/^void declaration(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
declaration_or_statement	parser.c	/^void declaration_or_statement(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
declaration_or_statement	parser.h	/^void declaration_or_statement(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
declaration_or_statement_list	parser.c	/^void declaration_or_statement_list(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
declaration_or_statement_list	parser.h	/^void declaration_or_statement_list(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
declaration_specifier	parser.c	/^var_type declaration_specifier(parsing_state* p, program_state* prog, int match)$/;"	f	signature:(parsing_state* p, program_state* prog, int match)
declaration_specifier	parser.h	/^var_type declaration_specifier(parsing_state* p, program_state* prog, int match);$/;"	p	signature:(parsing_state* p, program_state* prog, int match)
do_stmt	parser.c	/^void do_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
do_stmt	parser.h	/^void do_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
double_val	parser.h	/^		double double_val;$/;"	m	union:var_value::__anon3	access:public
elem_free	cvector.h	/^	void (*elem_free)(void*);$/;"	m	struct:vector_void	access:public
elem_init	cvector.h	/^	void (*elem_init)(void*, void*);$/;"	m	struct:vector_void	access:public
elem_size	c_utils.h	/^	size_t elem_size;$/;"	m	struct:c_array	access:public
elem_size	cvector.h	/^	size_t elem_size;        \/**< Size in u8s of type stored (sizeof(T) where T is type). *\/$/;"	m	struct:vector_void	access:public
equality_expr	parser.c	/^void equality_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
equality_expr	parser.h	/^void equality_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
erase_TYPE	vector_template.c	/^void erase_TYPE(vector_TYPE* vec, size_t start, size_t end)$/;"	f	signature:(vector_TYPE* vec, size_t start, size_t end)
erase_TYPE	vector_template.h	/^void erase_TYPE(vector_TYPE* vec, size_t start, size_t end);$/;"	p	signature:(vector_TYPE* vec, size_t start, size_t end)
erase_binding	vector_binding.c	/^void erase_binding(vector_binding* vec, size_t start, size_t end)$/;"	f	signature:(vector_binding* vec, size_t start, size_t end)
erase_binding	vector_binding.h	/^void erase_binding(vector_binding* vec, size_t start, size_t end);$/;"	p	signature:(vector_binding* vec, size_t start, size_t end)
erase_d	cvector.h	/^void erase_d(vector_d* vec, size_t start, size_t end)$/;"	f	signature:(vector_d* vec, size_t start, size_t end)
erase_d	cvector.h	/^void erase_d(vector_d* vec, size_t start, size_t end);$/;"	p	signature:(vector_d* vec, size_t start, size_t end)
erase_i	cvector.h	/^void erase_i(vector_i* vec, size_t start, size_t end)$/;"	f	signature:(vector_i* vec, size_t start, size_t end)
erase_i	cvector.h	/^void erase_i(vector_i* vec, size_t start, size_t end);$/;"	p	signature:(vector_i* vec, size_t start, size_t end)
erase_str	cvector.h	/^void erase_str(vector_str* vec, size_t start, size_t end)$/;"	f	signature:(vector_str* vec, size_t start, size_t end)
erase_str	cvector.h	/^void erase_str(vector_str* vec, size_t start, size_t end);$/;"	p	signature:(vector_str* vec, size_t start, size_t end)
erase_void	cvector.h	/^void erase_void(vector_void* vec, size_t start, size_t end)$/;"	f	signature:(vector_void* vec, size_t start, size_t end)
erase_void	cvector.h	/^void erase_void(vector_void* vec, size_t start, size_t end);$/;"	p	signature:(vector_void* vec, size_t start, size_t end)
europeandate	stats/sortable.js	/^var europeandate = true;$/;"	v
execute	interpreter.c	/^void execute(program_state* prog)$/;"	f	signature:(program_state* prog)
execute	interpreter.h	/^void execute(program_state* prog);$/;"	p	signature:(program_state* prog)
execute_constant_expr	interpreter.c	/^var_value execute_constant_expr(program_state* prog, expression* e)$/;"	f	signature:(program_state* prog, expression* e)
execute_constant_expr	interpreter.h	/^var_value execute_constant_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
execute_constant_expr	parser.h	/^var_value execute_constant_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
execute_expr	interpreter.c	/^var_value execute_expr(program_state* prog, expression* e)$/;"	f	signature:(program_state* prog, expression* e)
execute_expr	interpreter.h	/^var_value execute_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
execute_expr	parser.h	/^var_value execute_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
execute_expr_list	interpreter.c	/^void execute_expr_list(program_state* prog, function* callee, expression* e)$/;"	f	signature:(program_state* prog, function* callee, expression* e)
execute_expr_list	interpreter.h	/^void execute_expr_list(program_state* prog, function* callee, expression* e);$/;"	p	signature:(program_state* prog, function* callee, expression* e)
execute_goto	interpreter.c	/^void execute_goto(program_state* prog, statement* stmt)$/;"	f	signature:(program_state* prog, statement* stmt)
execute_goto	interpreter.h	/^void execute_goto(program_state* prog, statement* stmt);$/;"	p	signature:(program_state* prog, statement* stmt)
execute_print	interpreter.c	/^void execute_print(var_value a)$/;"	f	signature:(var_value a)
execute_print	interpreter.h	/^void execute_print(var_value a);$/;"	p	signature:(var_value a)
exp	parser.h	/^	expression* exp;$/;"	m	struct:statement	access:public
expr	parser.c	/^void expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
expr	parser.h	/^void expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
expr_block	parser.h	/^typedef struct expr_block$/;"	s
expr_block	parser.h	/^} expr_block;$/;"	t	typeref:struct:expr_block
expr_block::data	parser.h	/^	expression* data;$/;"	m	struct:expr_block	access:public
expr_block::n	parser.h	/^	size_t n;$/;"	m	struct:expr_block	access:public
expr_block::used	parser.h	/^	size_t used;$/;"	m	struct:expr_block	access:public
expression	parser.h	/^struct expression$/;"	s
expression	parser.h	/^typedef struct expression expression;$/;"	t	typeref:struct:expression
expression::left	parser.h	/^	expression* left;$/;"	m	struct:expression	access:public
expression::right	parser.h	/^	expression* right;$/;"	m	struct:expression	access:public
expression::tok	parser.h	/^	token_value tok;$/;"	m	struct:expression	access:public
expression_list	parser.c	/^void expression_list(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
expression_list	parser.h	/^void expression_list(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
expression_stmt	parser.c	/^void expression_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
expression_stmt	parser.h	/^void expression_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
expressions	parser.h	/^	vector_void expressions;$/;"	m	struct:program_state	access:public
extend_TYPE	vector_template.c	/^int extend_TYPE(vector_TYPE* vec, size_t num)$/;"	f	signature:(vector_TYPE* vec, size_t num)
extend_TYPE	vector_template.h	/^int extend_TYPE(vector_TYPE* vec, size_t num);$/;"	p	signature:(vector_TYPE* vec, size_t num)
extend_binding	vector_binding.c	/^int extend_binding(vector_binding* vec, size_t num)$/;"	f	signature:(vector_binding* vec, size_t num)
extend_binding	vector_binding.h	/^int extend_binding(vector_binding* vec, size_t num);$/;"	p	signature:(vector_binding* vec, size_t num)
extend_d	cvector.h	/^int extend_d(vector_d* vec, size_t num)$/;"	f	signature:(vector_d* vec, size_t num)
extend_d	cvector.h	/^int extend_d(vector_d* vec, size_t num);$/;"	p	signature:(vector_d* vec, size_t num)
extend_i	cvector.h	/^int extend_i(vector_i* vec, size_t num)$/;"	f	signature:(vector_i* vec, size_t num)
extend_i	cvector.h	/^int extend_i(vector_i* vec, size_t num);$/;"	p	signature:(vector_i* vec, size_t num)
extend_str	cvector.h	/^int extend_str(vector_str* vec, size_t num)$/;"	f	signature:(vector_str* vec, size_t num)
extend_str	cvector.h	/^int extend_str(vector_str* vec, size_t num);$/;"	p	signature:(vector_str* vec, size_t num)
extend_void	cvector.h	/^int extend_void(vector_void* vec, size_t num)$/;"	f	signature:(vector_void* vec, size_t num)
extend_void	cvector.h	/^int extend_void(vector_void* vec, size_t num);$/;"	p	signature:(vector_void* vec, size_t num)
extensions	stats/files.html	/^<h2><a href="#extensions" name="extensions">Extensions<\/a><\/h2>$/;"	a
fibbonaci	tests/functions.c	/^int fibbonaci(int n)$/;"	f	signature:(int n)
file_count_by_date	stats/files.html	/^<h2><a href="#file_count_by_date" name="file_count_by_date">File count by date<\/a><\/h2>$/;"	a
file_open_read	c_utils.c	/^int file_open_read(const char* filename, const char* mode, c_array* out)$/;"	f	signature:(const char* filename, const char* mode, c_array* out)
file_open_read	c_utils.h	/^int file_open_read(const char* filename, const char* mode, c_array* out);$/;"	p	signature:(const char* filename, const char* mode, c_array* out)
file_open_readlines	c_utils.c	/^int file_open_readlines(const char* filename, c_array* lines, c_array* file_contents)$/;"	f	signature:(const char* filename, c_array* lines, c_array* file_contents)
file_open_readlines	c_utils.h	/^int file_open_readlines(const char* filename, c_array* lines, c_array* file_contents);$/;"	p	signature:(const char* filename, c_array* lines, c_array* file_contents)
file_open_write	c_utils.c	/^int file_open_write(const char* filename, const char* mode, c_array* out)$/;"	f	signature:(const char* filename, const char* mode, c_array* out)
file_open_write	c_utils.h	/^int file_open_write(const char* filename, const char* mode, c_array* out);$/;"	p	signature:(const char* filename, const char* mode, c_array* out)
file_read	c_utils.c	/^int file_read(FILE* file, c_array* out)$/;"	f	signature:(FILE* file, c_array* out)
file_read	c_utils.h	/^int file_read(FILE* file, c_array* out);$/;"	p	signature:(FILE* file, c_array* out)
file_write	c_utils.c	/^int file_write(FILE* file, c_array* out)$/;"	f	signature:(FILE* file, c_array* out)
file_write	c_utils.h	/^int file_write(FILE* file, c_array* out);$/;"	p	signature:(FILE* file, c_array* out)
find_lowest_common_ancestor	interpreter.c	/^int find_lowest_common_ancestor(program_state* prog, int parent1, int parent2)$/;"	f	signature:(program_state* prog, int parent1, int parent2)
find_lowest_common_ancestor	interpreter.h	/^int find_lowest_common_ancestor(program_state* prog, int parent1, int parent2);$/;"	p	signature:(program_state* prog, int parent1, int parent2)
find_lowest_common_ancestor	parser.h	/^int find_lowest_common_ancestor(program_state* prog, int parent1, int parent2);$/;"	p	signature:(program_state* prog, int parent1, int parent2)
float_val	parser.h	/^		float float_val;$/;"	m	union:var_value::__anon3	access:public
for_stmt	parser.c	/^void for_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
for_stmt	parser.h	/^void for_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
fpeek	c_utils.c	/^int fpeek(FILE* input)$/;"	f	signature:(FILE* input)
fpeek	c_utils.h	/^int fpeek(FILE* input);$/;"	p	signature:(FILE* input)
freadline	c_utils.c	/^char* freadline(FILE* input)$/;"	f	signature:(FILE* input)
freadline	c_utils.h	/^char* freadline(FILE* input);$/;"	p	signature:(FILE* input)
freadline_into_str	c_utils.c	/^int freadline_into_str(FILE* input, char* str, size_t len)$/;"	f	signature:(FILE* input, char* str, size_t len)
freadline_into_str	c_utils.h	/^int freadline_into_str(FILE* input, char* str, size_t len);$/;"	p	signature:(FILE* input, char* str, size_t len)
freadstring	c_utils.c	/^char* freadstring(FILE* input, int delim, size_t max_len)$/;"	f	signature:(FILE* input, int delim, size_t max_len)
freadstring	c_utils.h	/^char* freadstring(FILE* input, int delim, size_t max_len);$/;"	p	signature:(FILE* input, int delim, size_t max_len)
freadstring_into_str	c_utils.c	/^int freadstring_into_str(FILE* input, int delim, char* str, size_t len)$/;"	f	signature:(FILE* input, int delim, char* str, size_t len)
freadstring_into_str	c_utils.h	/^int freadstring_into_str(FILE* input, int delim, char* str, size_t len);$/;"	p	signature:(FILE* input, int delim, char* str, size_t len)
free_active_binding_list	parser.c	/^void free_active_binding_list(void* l)$/;"	f	signature:(void* l)
free_active_binding_list	parser.h	/^void free_active_binding_list(void* l);$/;"	p	signature:(void* l)
free_expr_block	parser.c	/^void free_expr_block(void* block)$/;"	f	signature:(void* block)
free_function	parser.c	/^void free_function(void* func)$/;"	f	signature:(void* func)
free_statement	parser.c	/^void free_statement(void* stmt)$/;"	f	signature:(void* stmt)
free_statement	parser.h	/^void free_statement(void* stmt);$/;"	p	signature:(void* stmt)
free_symbol	parser.c	/^void free_symbol(void* var)$/;"	f	signature:(void* var)
free_var_value	parser.c	/^void free_var_value(void* var)$/;"	f	signature:(void* var)
free_var_value	parser.h	/^void free_var_value(void* var);$/;"	p	signature:(void* var)
free_vec_TYPE	vector_template.c	/^void free_vec_TYPE(void* vec)$/;"	f	signature:(void* vec)
free_vec_TYPE	vector_template.h	/^void free_vec_TYPE(void* vec);$/;"	p	signature:(void* vec)
free_vec_TYPE_heap	vector_template.c	/^void free_vec_TYPE_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_TYPE_heap	vector_template.h	/^void free_vec_TYPE_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_binding	vector_binding.c	/^void free_vec_binding(void* vec)$/;"	f	signature:(void* vec)
free_vec_binding	vector_binding.h	/^void free_vec_binding(void* vec);$/;"	p	signature:(void* vec)
free_vec_binding_heap	vector_binding.c	/^void free_vec_binding_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_binding_heap	vector_binding.h	/^void free_vec_binding_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_d	cvector.h	/^void free_vec_d(void* vec)$/;"	f	signature:(void* vec)
free_vec_d	cvector.h	/^void free_vec_d(void* vec);$/;"	p	signature:(void* vec)
free_vec_d_heap	cvector.h	/^void free_vec_d_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_d_heap	cvector.h	/^void free_vec_d_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_i	cvector.h	/^void free_vec_i(void* vec)$/;"	f	signature:(void* vec)
free_vec_i	cvector.h	/^void free_vec_i(void* vec);$/;"	p	signature:(void* vec)
free_vec_i_heap	cvector.h	/^void free_vec_i_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_i_heap	cvector.h	/^void free_vec_i_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_str	cvector.h	/^void free_vec_str(void* vec)$/;"	f	signature:(void* vec)
free_vec_str	cvector.h	/^void free_vec_str(void* vec);$/;"	p	signature:(void* vec)
free_vec_str_heap	cvector.h	/^void free_vec_str_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_str_heap	cvector.h	/^void free_vec_str_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_void	cvector.h	/^void free_vec_void(void* vec)$/;"	f	signature:(void* vec)
free_vec_void	cvector.h	/^void free_vec_void(void* vec);$/;"	p	signature:(void* vec)
free_vec_void_heap	cvector.h	/^void free_vec_void_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_void_heap	cvector.h	/^void free_vec_void_heap(void* vec);$/;"	p	signature:(void* vec)
func	parser.h	/^	function* func;$/;"	m	struct:program_state	access:public
func1	tests/functions.c	/^void func1(void)$/;"	f	signature:(void)
func2	tests/functions.c	/^void func2(int a, int b, int c)$/;"	f	signature:(int a, int b, int c)
func_loc	parser.h	/^		unsigned int func_loc; \/\/change to direct pointer?$/;"	m	union:var_value::__anon3	access:public
function	parser.h	/^typedef struct function$/;"	s
function	parser.h	/^} function;$/;"	t	typeref:struct:function
function::label_locs	parser.h	/^	vector_i label_locs;$/;"	m	struct:function	access:public
function::labels	parser.h	/^	vector_str labels;$/;"	m	struct:function	access:public
function::n_params	parser.h	/^	int n_params;$/;"	m	struct:function	access:public
function::pc	parser.h	/^	size_t pc;$/;"	m	struct:function	access:public
function::ret_val	parser.h	/^	var_value ret_val;$/;"	m	struct:function	access:public
function::stmt_list	parser.h	/^	vector_void stmt_list;$/;"	m	struct:function	access:public
function::symbols	parser.h	/^	vector_void symbols;$/;"	m	struct:function	access:public
function_call	parser.c	/^void function_call(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
function_call	parser.h	/^void function_call(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
function_declarator	parser.c	/^void function_declarator(parsing_state* p, program_state* prog, var_type vtype)$/;"	f	signature:(parsing_state* p, program_state* prog, var_type vtype)
function_declarator	parser.h	/^void function_declarator(parsing_state* p, program_state* prog, var_type vtype);$/;"	p	signature:(parsing_state* p, program_state* prog, var_type vtype)
function_definition	parser.c	/^void function_definition(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
function_definition	parser.h	/^void function_definition(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
functions	parser.h	/^	vector_void functions;$/;"	m	struct:program_state	access:public
gen_type	generate_code.py	/^gen_type = sys.argv[1];$/;"	v
getParent	stats/sortable.js	/^function getParent(el, pTagName) {$/;"	f
get_token	parser.c	/^token_value* get_token(parsing_state* p)$/;"	f	signature:(parsing_state* p)
global	tests/types.c	/^int global = 1.5;$/;"	v
global_values	parser.h	/^	vector_void global_values;$/;"	m	struct:program_state	access:public
global_variables	parser.h	/^	vector_str global_variables;$/;"	m	struct:program_state	access:public
goto_stmt	parser.c	/^void goto_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
goto_stmt	parser.h	/^void goto_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
h_out	generate_code.py	/^h_out = hfile_string.replace('TYPE', gen_type);$/;"	v
head	parser.h	/^	list_head head;$/;"	m	struct:symbol	access:public
hfile_string	generate_code.py	/^hfile_string = open("vector_template.h").read();$/;"	v
hour_of_day	stats/activity.html	/^<h2><a href="#hour_of_day" name="hour_of_day">Hour of Day<\/a><\/h2>$/;"	a
hour_of_week	stats/activity.html	/^<h2><a href="#hour_of_week" name="hour_of_week">Hour of Week<\/a><\/h2>$/;"	a
i	parser.h	/^	unsigned i;$/;"	m	struct:parsing_state	access:public
i	tests/experimenting.c	/^int i = 5;$/;"	v
id	parser.h	/^		char* id;$/;"	m	union:token_value::__anon4	access:public
if_stmt	parser.c	/^void if_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
if_stmt	parser.h	/^void if_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
image_down	stats/sortable.js	/^var image_down = "arrow-down.gif";$/;"	v
image_none	stats/sortable.js	/^var image_none = "arrow-none.gif";$/;"	v
image_path	stats/sortable.js	/^var image_path = "";$/;"	v
image_up	stats/sortable.js	/^var image_up = "arrow-up.gif";$/;"	v
init_c_array	c_utils.c	/^c_array init_c_array(byte* data, size_t elem_size, size_t len)$/;"	f	signature:(byte* data, size_t elem_size, size_t len)
init_c_array	c_utils.h	/^c_array init_c_array(byte* data, size_t elem_size, size_t len);$/;"	p	signature:(byte* data, size_t elem_size, size_t len)
init_function	parser.c	/^void init_function(void* to, void* from)$/;"	f	signature:(void* to, void* from)
init_vec_TYPE	vector_template.c	/^int init_vec_TYPE(vector_TYPE* vec, TYPE* vals, size_t num)$/;"	f	signature:(vector_TYPE* vec, TYPE* vals, size_t num)
init_vec_TYPE	vector_template.h	/^int init_vec_TYPE(vector_TYPE* vec, TYPE* vals, size_t num);$/;"	p	signature:(vector_TYPE* vec, TYPE* vals, size_t num)
init_vec_TYPE_heap	vector_template.c	/^vector_TYPE* init_vec_TYPE_heap(TYPE* vals, size_t num)$/;"	f	signature:(TYPE* vals, size_t num)
init_vec_TYPE_heap	vector_template.h	/^vector_TYPE* init_vec_TYPE_heap(TYPE* vals, size_t num);$/;"	p	signature:(TYPE* vals, size_t num)
init_vec_binding	vector_binding.c	/^int init_vec_binding(vector_binding* vec, binding* vals, size_t num)$/;"	f	signature:(vector_binding* vec, binding* vals, size_t num)
init_vec_binding	vector_binding.h	/^int init_vec_binding(vector_binding* vec, binding* vals, size_t num);$/;"	p	signature:(vector_binding* vec, binding* vals, size_t num)
init_vec_binding_heap	vector_binding.c	/^vector_binding* init_vec_binding_heap(binding* vals, size_t num)$/;"	f	signature:(binding* vals, size_t num)
init_vec_binding_heap	vector_binding.h	/^vector_binding* init_vec_binding_heap(binding* vals, size_t num);$/;"	p	signature:(binding* vals, size_t num)
init_vec_d	cvector.h	/^int init_vec_d(vector_d* vec, double* vals, size_t num)$/;"	f	signature:(vector_d* vec, double* vals, size_t num)
init_vec_d	cvector.h	/^int init_vec_d(vector_d* vec, double* vals, size_t num);$/;"	p	signature:(vector_d* vec, double* vals, size_t num)
init_vec_d_heap	cvector.h	/^vector_d* init_vec_d_heap(double* vals, size_t num)$/;"	f	signature:(double* vals, size_t num)
init_vec_d_heap	cvector.h	/^vector_d* init_vec_d_heap(double* vals, size_t num);$/;"	p	signature:(double* vals, size_t num)
init_vec_i	cvector.h	/^int init_vec_i(vector_i* vec, int* vals, size_t num)$/;"	f	signature:(vector_i* vec, int* vals, size_t num)
init_vec_i	cvector.h	/^int init_vec_i(vector_i* vec, int* vals, size_t num);$/;"	p	signature:(vector_i* vec, int* vals, size_t num)
init_vec_i_heap	cvector.h	/^vector_i* init_vec_i_heap(int* vals, size_t num)$/;"	f	signature:(int* vals, size_t num)
init_vec_i_heap	cvector.h	/^vector_i* init_vec_i_heap(int* vals, size_t num);$/;"	p	signature:(int* vals, size_t num)
init_vec_str	cvector.h	/^int init_vec_str(vector_str* vec, char** vals, size_t num)$/;"	f	signature:(vector_str* vec, char** vals, size_t num)
init_vec_str	cvector.h	/^int init_vec_str(vector_str* vec, char** vals, size_t num);$/;"	p	signature:(vector_str* vec, char** vals, size_t num)
init_vec_str_heap	cvector.h	/^vector_str* init_vec_str_heap(char** vals, size_t num)$/;"	f	signature:(char** vals, size_t num)
init_vec_str_heap	cvector.h	/^vector_str* init_vec_str_heap(char** vals, size_t num);$/;"	p	signature:(char** vals, size_t num)
init_vec_void	cvector.h	/^int init_vec_void(vector_void* vec, void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(vector_void* vec, void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_void	cvector.h	/^int init_vec_void(vector_void* vec, void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(vector_void* vec, void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_void_heap	cvector.h	/^vector_void* init_vec_void_heap(void* vals, size_t num, size_t elem_sz, void (*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(void* vals, size_t num, size_t elem_sz, void (*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_void_heap	cvector.h	/^vector_void* init_vec_void_heap(void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
initialized_declarator	parser.c	/^void initialized_declarator(parsing_state* p, program_state* prog, var_type v_type)$/;"	f	signature:(parsing_state* p, program_state* prog, var_type v_type)
initialized_declarator	parser.h	/^void initialized_declarator(parsing_state* p, program_state* prog, var_type v_type);$/;"	p	signature:(parsing_state* p, program_state* prog, var_type v_type)
initialized_declarator_list	parser.c	/^void initialized_declarator_list(parsing_state* p, program_state* prog, var_type v_type)$/;"	f	signature:(parsing_state* p, program_state* prog, var_type v_type)
initialized_declarator_list	parser.h	/^void initialized_declarator_list(parsing_state* p, program_state* prog, var_type v_type);$/;"	p	signature:(parsing_state* p, program_state* prog, var_type v_type)
insert_TYPE	vector_template.c	/^int insert_TYPE(vector_TYPE* vec, size_t i, TYPE a)$/;"	f	signature:(vector_TYPE* vec, size_t i, TYPE a)
insert_TYPE	vector_template.h	/^int insert_TYPE(vector_TYPE* vec, size_t i, TYPE a);$/;"	p	signature:(vector_TYPE* vec, size_t i, TYPE a)
insert_array_TYPE	vector_template.c	/^int insert_array_TYPE(vector_TYPE* vec, size_t i, TYPE* a, size_t num)$/;"	f	signature:(vector_TYPE* vec, size_t i, TYPE* a, size_t num)
insert_array_TYPE	vector_template.h	/^int insert_array_TYPE(vector_TYPE* vec, size_t i, TYPE* a, size_t num);$/;"	p	signature:(vector_TYPE* vec, size_t i, TYPE* a, size_t num)
insert_array_binding	vector_binding.c	/^int insert_array_binding(vector_binding* vec, size_t i, binding* a, size_t num)$/;"	f	signature:(vector_binding* vec, size_t i, binding* a, size_t num)
insert_array_binding	vector_binding.h	/^int insert_array_binding(vector_binding* vec, size_t i, binding* a, size_t num);$/;"	p	signature:(vector_binding* vec, size_t i, binding* a, size_t num)
insert_array_d	cvector.h	/^int insert_array_d(vector_d* vec, size_t i, double* a, size_t num)$/;"	f	signature:(vector_d* vec, size_t i, double* a, size_t num)
insert_array_d	cvector.h	/^int insert_array_d(vector_d* vec, size_t i, double* a, size_t num);$/;"	p	signature:(vector_d* vec, size_t i, double* a, size_t num)
insert_array_i	cvector.h	/^int insert_array_i(vector_i* vec, size_t i, int* a, size_t num)$/;"	f	signature:(vector_i* vec, size_t i, int* a, size_t num)
insert_array_i	cvector.h	/^int insert_array_i(vector_i* vec, size_t i, int* a, size_t num);$/;"	p	signature:(vector_i* vec, size_t i, int* a, size_t num)
insert_array_str	cvector.h	/^int insert_array_str(vector_str* vec, size_t i, char** , size_t num);$/;"	p	signature:(vector_str* vec, size_t i, char** , size_t num)
insert_array_str	cvector.h	/^int insert_array_str(vector_str* vec, size_t i, char** a, size_t num)$/;"	f	signature:(vector_str* vec, size_t i, char** a, size_t num)
insert_array_void	cvector.h	/^int insert_array_void(vector_void* vec, size_t i, void* a, size_t num)$/;"	f	signature:(vector_void* vec, size_t i, void* a, size_t num)
insert_array_void	cvector.h	/^int insert_array_void(vector_void* vec, size_t i, void* a, size_t num);$/;"	p	signature:(vector_void* vec, size_t i, void* a, size_t num)
insert_binding	vector_binding.c	/^int insert_binding(vector_binding* vec, size_t i, binding a)$/;"	f	signature:(vector_binding* vec, size_t i, binding a)
insert_binding	vector_binding.h	/^int insert_binding(vector_binding* vec, size_t i, binding a);$/;"	p	signature:(vector_binding* vec, size_t i, binding a)
insert_d	cvector.h	/^int insert_d(vector_d* vec, size_t i, double a)$/;"	f	signature:(vector_d* vec, size_t i, double a)
insert_d	cvector.h	/^int insert_d(vector_d* vec, size_t i, double a);$/;"	p	signature:(vector_d* vec, size_t i, double a)
insert_i	cvector.h	/^int insert_i(vector_i* vec, size_t i, int a)$/;"	f	signature:(vector_i* vec, size_t i, int a)
insert_i	cvector.h	/^int insert_i(vector_i* vec, size_t i, int a);$/;"	p	signature:(vector_i* vec, size_t i, int a)
insert_str	cvector.h	/^int insert_str(vector_str* vec, size_t i, char* a)$/;"	f	signature:(vector_str* vec, size_t i, char* a)
insert_str	cvector.h	/^int insert_str(vector_str* vec, size_t i, char* a);$/;"	p	signature:(vector_str* vec, size_t i, char* a)
insert_void	cvector.h	/^int insert_void(vector_void* vec, size_t i, void* a)$/;"	f	signature:(vector_void* vec, size_t i, void* a)
insert_void	cvector.h	/^int insert_void(vector_void* vec, size_t i, void* a);$/;"	p	signature:(vector_void* vec, size_t i, void* a)
int_list	clist.h	/^typedef struct int_list$/;"	s
int_list	clist.h	/^} int_list;$/;"	t	typeref:struct:int_list
int_list::data	clist.h	/^	int data;$/;"	m	struct:int_list	access:public
int_list::list	clist.h	/^	list_head list;$/;"	m	struct:int_list	access:public
int_val	parser.h	/^		int int_val;$/;"	m	union:var_value::__anon3	access:public
integer	parser.h	/^		int integer;$/;"	m	union:token_value::__anon4	access:public
is_ancestor	interpreter.c	/^int is_ancestor(program_state* prog, int parent, int child)$/;"	f	signature:(program_state* prog, int parent, int child)
is_ancestor	interpreter.h	/^int is_ancestor(program_state* prog, int parent, int child);$/;"	p	signature:(program_state* prog, int parent, int child)
is_ancestor	parser.h	/^int is_ancestor(program_state* prog, int parent, int child);$/;"	p	signature:(program_state* prog, int parent, int child)
is_any	c_utils.c	/^int is_any(c_array* array, const void* the_one, int (*are_equal)(const void*, const void*))$/;"	f	signature:(c_array* array, const void* the_one, int (*are_equal)(const void*, const void*))
is_any	c_utils.h	/^int is_any(c_array* array, const void* the_one, int (*are_equal)(const void*, const void*));$/;"	p	signature:(c_array* array, const void* the_one, int (*are_equal)(const void*, const void*))
is_integral_type	parser.c	/^int is_integral_type(var_value* v)$/;"	f	signature:(var_value* v)
is_true	interpreter.c	/^int is_true(var_value v)$/;"	f	signature:(var_value v)
is_true	interpreter.h	/^int is_true(var_value v);$/;"	p	signature:(var_value v)
jump_to	parser.h	/^	size_t jump_to;$/;"	m	struct:statement	access:public
jump_to	parser.h	/^	unsigned int jump_to;$/;"	m	struct:a_case	access:public
label_locs	parser.h	/^	vector_i label_locs;$/;"	m	struct:function	access:public
labeled_stmt	parser.c	/^void labeled_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
labeled_stmt	parser.h	/^void labeled_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
labels	parser.h	/^	vector_str labels;$/;"	m	struct:function	access:public
left	parser.h	/^	expression* left;$/;"	m	struct:expression	access:public
len	c_utils.h	/^	size_t len;$/;"	m	struct:c_array	access:public
lines_of_code	stats/lines.html	/^<h2><a href="#lines_of_code" name="lines_of_code">Lines of Code<\/a><\/h2>$/;"	a
list	clist.h	/^	list_head list;$/;"	m	struct:int_list	access:public
list	parser.h	/^	list_head list;$/;"	m	struct:active_binding	access:public
list_add	clist.h	/^static inline void list_add(list_head* item, list_head* head)$/;"	f	signature:(list_head* item, list_head* head)
list_add_tail	clist.h	/^static inline void list_add_tail(list_head* item, list_head* head)$/;"	f	signature:(list_head* item, list_head* head)
list_del	clist.h	/^static inline void list_del(list_head* item)$/;"	f	signature:(list_head* item)
list_empty	clist.h	/^static inline int list_empty(const list_head *head)$/;"	f	signature:(const list_head *head)
list_entry	clist.h	89;"	d
list_first_entry	clist.h	100;"	d
list_first_entry_or_null	clist.h	111;"	d
list_for_each	clist.h	119;"	d
list_for_each_entry	clist.h	169;"	d
list_for_each_entry_continue	clist.h	197;"	d
list_for_each_entry_continue_reverse	clist.h	212;"	d
list_for_each_entry_from	clist.h	226;"	d
list_for_each_entry_reverse	clist.h	181;"	d
list_for_each_entry_safe	clist.h	238;"	d
list_for_each_entry_safe_continue	clist.h	255;"	d
list_for_each_entry_safe_from	clist.h	272;"	d
list_for_each_entry_safe_reverse	clist.h	288;"	d
list_for_each_prev	clist.h	138;"	d
list_for_each_prev_safe	clist.h	157;"	d
list_for_each_safe	clist.h	147;"	d
list_head	clist.h	/^typedef struct list_head$/;"	s
list_head	clist.h	/^} list_head;$/;"	t	typeref:struct:list_head
list_head::next	clist.h	/^	struct list_head* next;$/;"	m	struct:list_head	typeref:struct:list_head::list_head	access:public
list_head::prev	clist.h	/^	struct list_head* prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head	access:public
list_is_last	clist.h	/^static inline int list_is_last(const list_head *list, const list_head *head)$/;"	f	signature:(const list_head *list, const list_head *head)
list_is_singular	clist.h	/^static inline int list_is_singular(const list_head *head)$/;"	f	signature:(const list_head *head)
list_of_authors	stats/authors.html	/^<h2><a href="#list_of_authors" name="list_of_authors">List of Authors<\/a><\/h2>$/;"	a
list_replace	clist.h	/^static inline void list_replace(list_head* old, list_head* item)$/;"	f	signature:(list_head* old, list_head* item)
list_swap	clist.h	/^void list_swap(list_head* p, list_head* q)$/;"	f	signature:(list_head* p, list_head* q)
list_swap	clist.h	/^void list_swap(list_head* p, list_head* q);$/;"	p	signature:(list_head* p, list_head* q)
logical_and_expr	parser.c	/^void logical_and_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
logical_and_expr	parser.h	/^void logical_and_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
logical_negation_expr	parser.c	/^void logical_negation_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
logical_negation_expr	parser.h	/^void logical_negation_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
logical_or_expr	parser.c	/^void logical_or_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
logical_or_expr	parser.h	/^void logical_or_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
long_val	parser.h	/^		long long_val;$/;"	m	union:var_value::__anon3	access:public
look_up_loc	interpreter.c	/^unsigned int look_up_loc(program_state* prog, const char* var)$/;"	f	signature:(program_state* prog, const char* var)
look_up_loc	interpreter.h	/^unsigned int look_up_loc(program_state* prog, const char* var);$/;"	p	signature:(program_state* prog, const char* var)
look_up_loc	parser.h	/^unsigned int look_up_loc(program_state* prog, const char* var);$/;"	p	signature:(program_state* prog, const char* var)
look_up_symbol	interpreter.c	/^symbol* look_up_symbol(program_state* prog, const char* var)$/;"	f	signature:(program_state* prog, const char* var)
look_up_symbol	interpreter.h	/^symbol* look_up_symbol(program_state* prog, const char* var);$/;"	p	signature:(program_state* prog, const char* var)
look_up_symbol	parser.h	/^symbol* look_up_symbol(program_state* prog, const char* var);$/;"	p	signature:(program_state* prog, const char* var)
look_up_value	interpreter.c	/^var_value* look_up_value(program_state* prog, const char* var, int search)$/;"	f	signature:(program_state* prog, const char* var, int search)
look_up_value	interpreter.h	/^var_value* look_up_value(program_state* prog, const char* var, int search);$/;"	p	signature:(program_state* prog, const char* var, int search)
look_up_value	parser.h	/^var_value* look_up_value(program_state* prog, const char* var, int search);$/;"	p	signature:(program_state* prog, const char* var, int search)
ltrim	c_utils.c	/^char* ltrim(char* str)$/;"	f	signature:(char* str)
ltrim	c_utils.h	/^char* ltrim(char* str);$/;"	p	signature:(char* str)
lvalue	parser.h	/^	char* lvalue;$/;"	m	struct:statement	access:public
main	main.c	/^int main(int argc, char** argv)$/;"	f	signature:(int argc, char** argv)
main	tests/break_continue.c	/^int main()$/;"	f
main	tests/declarations.c	/^int main()$/;"	f
main	tests/dowhile.c	/^int main()$/;"	f
main	tests/experimenting.c	/^int main()$/;"	f
main	tests/for_stmt.c	/^int main()$/;"	f
main	tests/functions.c	/^int main()$/;"	f
main	tests/goto_label.c	/^int main()$/;"	f
main	tests/ifelse.c	/^int main()$/;"	f
main	tests/newtest.c	/^int main()$/;"	f
main	tests/scope.c	/^int main()$/;"	f
main	tests/switch.c	/^int main()$/;"	f
main	tests/ternary.c	/^int main()$/;"	f
main	tests/types.c	/^int main()$/;"	f
make_expression	parser.c	/^expression* make_expression(program_state* prog)$/;"	f	signature:(program_state* prog)
make_expression	parser.h	/^expression* make_expression(program_state* prog);$/;"	p	signature:(program_state* prog)
make_expression_block	parser.c	/^int make_expression_block(size_t n, expr_block* block)$/;"	f	signature:(size_t n, expr_block* block)
make_expression_block	parser.h	/^int make_expression_block(size_t n, expr_block* block);$/;"	p	signature:(size_t n, expr_block* block)
map	c_utils.c	/^void map(c_array* array, void (*func)(const void*))$/;"	f	signature:(c_array* array, void (*func)(const void*))
map	c_utils.h	/^void map(c_array* array, void (*func)(const void*));$/;"	p	signature:(c_array* array, void (*func)(const void*))
month_of_year	stats/activity.html	/^<h2><a href="#month_of_year" name="month_of_year">Month of Year<\/a><\/h2>$/;"	a
mult_expr	parser.c	/^void mult_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
mult_expr	parser.h	/^void mult_expr(parsing_state* p, program_state* prog, expression* exp);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* exp)
mybsearch	c_utils.c	/^void* mybsearch(const void *key, const void *buf, size_t num, size_t size, int (*compare)(const void *, const void *))$/;"	f	signature:(const void *key, const void *buf, size_t num, size_t size, int (*compare)(const void *, const void *))
mystrdup	c_utils.c	/^char* mystrdup(const char* str)$/;"	f	signature:(const char* str)
mystrdup	c_utils.h	/^char* mystrdup(const char* str);$/;"	p	signature:(const char* str)
n	parser.h	/^	size_t n;$/;"	m	struct:expr_block	access:public
n_params	parser.h	/^	int n_params;$/;"	m	struct:function	access:public
name	parser.h	/^	char* name;$/;"	m	struct:binding	access:public
name	parser.h	/^	char* name;$/;"	m	struct:symbol	access:public
next	clist.h	/^	struct list_head* next;$/;"	m	struct:list_head	typeref:struct:list_head::list_head	access:public
offsetof	clist.h	78;"	d
parameter_declaration	parser.c	/^void parameter_declaration(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
parameter_declaration	parser.h	/^void parameter_declaration(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
parameter_list	parser.c	/^void parameter_list(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
parameter_list	parser.h	/^void parameter_list(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
parent	parser.h	/^	int parent;$/;"	m	struct:active_binding	access:public
parent	parser.h	/^	long parent;$/;"	m	struct:statement	access:public
parse_error	parser.c	/^void parse_error(token_value* tok, char *str, ...)$/;"	f	signature:(token_value* tok, char *str, ...)
parse_error	parser.h	/^void parse_error(token_value* tok, char *str, ...);$/;"	p	signature:(token_value* tok, char *str, ...)
parse_program	parser.c	/^void parse_program(program_state* prog, FILE* file)$/;"	f	signature:(program_state* prog, FILE* file)
parse_program	parser.h	/^void parse_program(program_state* prog, FILE* file);$/;"	p	signature:(program_state* prog, FILE* file)
parse_seek	parser.c	/^void parse_seek(parsing_state* p, int origin, long offset)$/;"	f	signature:(parsing_state* p, int origin, long offset)
parse_seek	parser.h	/^void parse_seek(parsing_state* p, int origin, long offset);$/;"	p	signature:(parsing_state* p, int origin, long offset)
parsing_state	parser.h	/^typedef struct parsing_state$/;"	s
parsing_state	parser.h	/^} parsing_state;$/;"	t	typeref:struct:parsing_state
parsing_state::i	parser.h	/^	unsigned i;$/;"	m	struct:parsing_state	access:public
parsing_state::pos	parser.h	/^	unsigned int pos;$/;"	m	struct:parsing_state	access:public
parsing_state::tokens	parser.h	/^	vector_void tokens;$/;"	m	struct:parsing_state	access:public
pc	parser.h	/^	size_t pc;$/;"	m	struct:function	access:public
pc	parser.h	/^	size_t* pc;$/;"	m	struct:program_state	access:public
peek_token	parser.c	/^token_value* peek_token(parsing_state* p, long offset)$/;"	f	signature:(parsing_state* p, long offset)
peek_token	parser.h	/^token_value* peek_token(parsing_state* p, long offset);$/;"	p	signature:(parsing_state* p, long offset)
pop_TYPE	vector_template.c	/^TYPE pop_TYPE(vector_TYPE* vec)$/;"	f	signature:(vector_TYPE* vec)
pop_TYPE	vector_template.h	/^TYPE pop_TYPE(vector_TYPE* vec);$/;"	p	signature:(vector_TYPE* vec)
pop_binding	vector_binding.c	/^binding pop_binding(vector_binding* vec)$/;"	f	signature:(vector_binding* vec)
pop_binding	vector_binding.h	/^binding pop_binding(vector_binding* vec);$/;"	p	signature:(vector_binding* vec)
pop_d	cvector.h	/^double pop_d(vector_d* vec)$/;"	f	signature:(vector_d* vec)
pop_d	cvector.h	/^double pop_d(vector_d* vec);$/;"	p	signature:(vector_d* vec)
pop_i	cvector.h	/^int pop_i(vector_i* vec)$/;"	f	signature:(vector_i* vec)
pop_i	cvector.h	/^int pop_i(vector_i* vec);$/;"	p	signature:(vector_i* vec)
pop_scope	interpreter.c	/^void pop_scope(program_state* prog)$/;"	f	signature:(program_state* prog)
pop_scope	interpreter.h	/^void pop_scope(program_state* prog);$/;"	p	signature:(program_state* prog)
pop_scope	parser.h	/^void pop_scope(program_state* prog);$/;"	p	signature:(program_state* prog)
pop_str	cvector.h	/^void pop_str(vector_str* vec, char* ret)$/;"	f	signature:(vector_str* vec, char* ret)
pop_str	cvector.h	/^void pop_str(vector_str* vec, char* ret);$/;"	p	signature:(vector_str* vec, char* ret)
pop_void	cvector.h	/^void pop_void(vector_void* vec, void* ret)$/;"	f	signature:(vector_void* vec, void* ret)
pop_void	cvector.h	/^void pop_void(vector_void* vec, void* ret);$/;"	p	signature:(vector_void* vec, void* ret)
pos	parser.h	/^	unsigned int pos;$/;"	m	struct:parsing_state	access:public
postfix_expr	parser.c	/^void postfix_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
postfix_expr	parser.h	/^void postfix_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
pre_inc_decrement_expr	parser.c	/^void pre_inc_decrement_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
pre_inc_decrement_expr	parser.h	/^void pre_inc_decrement_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
prepare_badcharacter_heuristic	c_utils.c	/^void prepare_badcharacter_heuristic(const byte *str, size_t str_len, int result[ALPHABET_SIZE])$/;"	f	signature:(const byte *str, size_t str_len, int result[ALPHABET_SIZE])
prepare_goodsuffix_heuristic	c_utils.c	/^void prepare_goodsuffix_heuristic(const byte *str, size_t str_len, int result[])$/;"	f	signature:(const byte *str, size_t str_len, int result[])
prev	clist.h	/^	struct list_head* prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head	access:public
primary_expr	parser.c	/^void primary_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
primary_expr	parser.h	/^void primary_expr(parsing_state* p, program_state* prog, expression* exp);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* exp)
print_statement	parser.c	/^void print_statement(statement* stmt)$/;"	f	signature:(statement* stmt)
print_statement	parser.h	/^void print_statement(statement* stmt);$/;"	p	signature:(statement* stmt)
print_stmt	parser.c	/^void print_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
print_stmt	parser.h	/^void print_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
print_token	parser.c	/^void print_token(token_value* tok)$/;"	f	signature:(token_value* tok)
print_token	parser.h	/^void print_token(token_value* tok);$/;"	p	signature:(token_value* tok)
program_state	parser.h	/^typedef struct program_state$/;"	s
program_state	parser.h	/^} program_state;$/;"	t	typeref:struct:program_state
program_state::bindings	parser.h	/^	vector_void* bindings;$/;"	m	struct:program_state	access:public
program_state::cur_iter	parser.h	/^	int cur_iter;$/;"	m	struct:program_state	access:public
program_state::cur_iter_switch	parser.h	/^	int cur_iter_switch;$/;"	m	struct:program_state	access:public
program_state::cur_parent	parser.h	/^	int cur_parent; \/\/<-- location of open block statement$/;"	m	struct:program_state	access:public
program_state::expressions	parser.h	/^	vector_void expressions;$/;"	m	struct:program_state	access:public
program_state::func	parser.h	/^	function* func;$/;"	m	struct:program_state	access:public
program_state::functions	parser.h	/^	vector_void functions;$/;"	m	struct:program_state	access:public
program_state::global_values	parser.h	/^	vector_void global_values;$/;"	m	struct:program_state	access:public
program_state::global_variables	parser.h	/^	vector_str global_variables;$/;"	m	struct:program_state	access:public
program_state::pc	parser.h	/^	size_t* pc;$/;"	m	struct:program_state	access:public
program_state::stmt_list	parser.h	/^	vector_void* stmt_list;$/;"	m	struct:program_state	access:public
program_state::string_db	parser.h	/^	vector_str string_db;$/;"	m	struct:program_state	access:public
ptr	parser.h	/^		unsigned int ptr;$/;"	m	union:var_value::__anon3	access:public
push_TYPE	vector_template.c	/^int push_TYPE(vector_TYPE* vec, TYPE a)$/;"	f	signature:(vector_TYPE* vec, TYPE a)
push_TYPE	vector_template.h	/^int push_TYPE(vector_TYPE* vec, TYPE a);$/;"	p	signature:(vector_TYPE* vec, TYPE a)
push_binding	vector_binding.c	/^int push_binding(vector_binding* vec, binding a)$/;"	f	signature:(vector_binding* vec, binding a)
push_binding	vector_binding.h	/^int push_binding(vector_binding* vec, binding a);$/;"	p	signature:(vector_binding* vec, binding a)
push_d	cvector.h	/^int push_d(vector_d* vec, double a)$/;"	f	signature:(vector_d* vec, double a)
push_d	cvector.h	/^int push_d(vector_d* vec, double a);$/;"	p	signature:(vector_d* vec, double a)
push_i	cvector.h	/^int push_i(vector_i* vec, int a)$/;"	f	signature:(vector_i* vec, int a)
push_i	cvector.h	/^int push_i(vector_i* vec, int a);$/;"	p	signature:(vector_i* vec, int a)
push_str	cvector.h	/^int push_str(vector_str* vec, char* a)$/;"	f	signature:(vector_str* vec, char* a)
push_str	cvector.h	/^int push_str(vector_str* vec, char* a);$/;"	p	signature:(vector_str* vec, char* a)
push_void	cvector.h	/^int push_void(vector_void* vec, void* a)$/;"	f	signature:(vector_void* vec, void* a)
push_void	cvector.h	/^int push_void(vector_void* vec, void* val);$/;"	p	signature:(vector_void* vec, void* val)
read_char	c_utils.c	/^int read_char(FILE* input, char* skip_chars, int complement, int clear_line)$/;"	f	signature:(FILE* input, char* skip_chars, int complement, int clear_line)
read_char	c_utils.h	/^int read_char(FILE* input, char* skip_chars, int complement, int clear_line);$/;"	p	signature:(FILE* input, char* skip_chars, int complement, int clear_line)
read_string	c_utils.c	/^char* read_string(FILE* file, char* skip_chars, int delim, size_t max_len)$/;"	f	signature:(FILE* file, char* skip_chars, int delim, size_t max_len)
read_string	c_utils.h	/^char* read_string(FILE* file, char* skip_chars, int delim, size_t max_len);$/;"	p	signature:(FILE* file, char* skip_chars, int delim, size_t max_len)
read_token	parser.c	/^token_value read_token(FILE* file)$/;"	f	signature:(FILE* file)
readline	c_utils.c	/^char* readline(c_array* input)$/;"	f	signature:(c_array* input)
readline	c_utils.h	/^char* readline(c_array* input);$/;"	p	signature:(c_array* input)
readline_into_str	c_utils.c	/^int readline_into_str(c_array* input, char* str, size_t len)$/;"	f	signature:(c_array* input, char* str, size_t len)
readline_into_str	c_utils.h	/^int readline_into_str(c_array* input, char* str, size_t len);$/;"	p	signature:(c_array* input, char* str, size_t len)
readstring	c_utils.c	/^char* readstring(c_array* input, char delim, size_t max_len)$/;"	f	signature:(c_array* input, char delim, size_t max_len)
readstring	c_utils.h	/^char* readstring(c_array* input, char delim, size_t max_len);$/;"	p	signature:(c_array* input, char delim, size_t max_len)
readstring_into_str	c_utils.c	/^int readstring_into_str(c_array* input, char delim, char* str, size_t len)$/;"	f	signature:(c_array* input, char delim, char* str, size_t len)
readstring_into_str	c_utils.h	/^int readstring_into_str(c_array* input, char delim, char* str, size_t len);$/;"	p	signature:(c_array* input, char delim, char* str, size_t len)
real	parser.h	/^		double real;$/;"	m	union:token_value::__anon4	access:public
relational_expr	parser.c	/^void relational_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
relational_expr	parser.h	/^void relational_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
remove_binding	interpreter.c	/^void remove_binding(program_state* prog, char* name)$/;"	f	signature:(program_state* prog, char* name)
remove_binding	interpreter.h	/^void remove_binding(program_state* prog, char* name);$/;"	p	signature:(program_state* prog, char* name)
remove_binding	parser.h	/^void remove_binding(program_state* prog, char* name);$/;"	p	signature:(program_state* prog, char* name)
remove_binding_symbol	interpreter.c	/^void remove_binding_symbol(symbol* s)$/;"	f	signature:(symbol* s)
remove_scope	interpreter.c	/^void remove_scope(program_state* prog, int jump_to, int child, int parent)$/;"	f	signature:(program_state* prog, int jump_to, int child, int parent)
remove_scope	interpreter.h	/^void remove_scope(program_state* prog, int jump_to, int child, int parent);$/;"	p	signature:(program_state* prog, int jump_to, int child, int parent)
remove_scope	parser.h	/^void remove_scope(program_state* prog, int jump_to, int child, int parent);$/;"	p	signature:(program_state* prog, int jump_to, int child, int parent)
reserve_TYPE	vector_template.c	/^int reserve_TYPE(vector_TYPE* vec, size_t size)$/;"	f	signature:(vector_TYPE* vec, size_t size)
reserve_TYPE	vector_template.h	/^int reserve_TYPE(vector_TYPE* vec, size_t size);$/;"	p	signature:(vector_TYPE* vec, size_t size)
reserve_binding	vector_binding.c	/^int reserve_binding(vector_binding* vec, size_t size)$/;"	f	signature:(vector_binding* vec, size_t size)
reserve_binding	vector_binding.h	/^int reserve_binding(vector_binding* vec, size_t size);$/;"	p	signature:(vector_binding* vec, size_t size)
reserve_d	cvector.h	/^int reserve_d(vector_d* vec, size_t size)$/;"	f	signature:(vector_d* vec, size_t size)
reserve_d	cvector.h	/^int reserve_d(vector_d* vec, size_t size);$/;"	p	signature:(vector_d* vec, size_t size)
reserve_i	cvector.h	/^int reserve_i(vector_i* vec, size_t size)$/;"	f	signature:(vector_i* vec, size_t size)
reserve_i	cvector.h	/^int reserve_i(vector_i* vec, size_t size);$/;"	p	signature:(vector_i* vec, size_t size)
reserve_str	cvector.h	/^int reserve_str(vector_str* vec, size_t size)$/;"	f	signature:(vector_str* vec, size_t size)
reserve_str	cvector.h	/^int reserve_str(vector_str* vec, size_t size);$/;"	p	signature:(vector_str* vec, size_t size)
reserve_void	cvector.h	/^int reserve_void(vector_void* vec, size_t size)$/;"	f	signature:(vector_void* vec, size_t size)
reserve_void	cvector.h	/^int reserve_void(vector_void* vec, size_t size);$/;"	p	signature:(vector_void* vec, size_t size)
ret_val	parser.h	/^	var_value ret_val;$/;"	m	struct:function	access:public
return_stmt	parser.c	/^void return_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
return_stmt	parser.h	/^void return_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
right	parser.h	/^	expression* right;$/;"	m	struct:expression	access:public
rtrim	c_utils.c	/^char* rtrim(char* str)$/;"	f	signature:(char* str)
rtrim	c_utils.h	/^char* rtrim(char* str);$/;"	p	signature:(char* str)
run	interpreter.c	/^void run(program_state* prog, char* start_func)$/;"	f	signature:(program_state* prog, char* start_func)
run	interpreter.h	/^void run(program_state* prog, char* start_func);$/;"	p	signature:(program_state* prog, char* start_func)
set_capacity_TYPE	vector_template.c	/^int set_capacity_TYPE(vector_TYPE* vec, size_t size)$/;"	f	signature:(vector_TYPE* vec, size_t size)
set_capacity_TYPE	vector_template.h	/^int set_capacity_TYPE(vector_TYPE* vec, size_t size);$/;"	p	signature:(vector_TYPE* vec, size_t size)
set_capacity_binding	vector_binding.c	/^int set_capacity_binding(vector_binding* vec, size_t size)$/;"	f	signature:(vector_binding* vec, size_t size)
set_capacity_binding	vector_binding.h	/^int set_capacity_binding(vector_binding* vec, size_t size);$/;"	p	signature:(vector_binding* vec, size_t size)
set_capacity_d	cvector.h	/^int set_capacity_d(vector_d* vec, size_t size)$/;"	f	signature:(vector_d* vec, size_t size)
set_capacity_d	cvector.h	/^int set_capacity_d(vector_d* vec, size_t size);$/;"	p	signature:(vector_d* vec, size_t size)
set_capacity_i	cvector.h	/^int set_capacity_i(vector_i* vec, size_t size)$/;"	f	signature:(vector_i* vec, size_t size)
set_capacity_i	cvector.h	/^int set_capacity_i(vector_i* vec, size_t size);$/;"	p	signature:(vector_i* vec, size_t size)
set_capacity_str	cvector.h	/^int set_capacity_str(vector_str* vec, size_t size)$/;"	f	signature:(vector_str* vec, size_t size)
set_capacity_str	cvector.h	/^int set_capacity_str(vector_str* vec, size_t size);$/;"	p	signature:(vector_str* vec, size_t size)
set_capacity_void	cvector.h	/^int set_capacity_void(vector_void* vec, size_t size)$/;"	f	signature:(vector_void* vec, size_t size)
set_capacity_void	cvector.h	/^int set_capacity_void(vector_void* vec, size_t size);$/;"	p	signature:(vector_void* vec, size_t size)
set_val_cap_TYPE	vector_template.c	/^void set_val_cap_TYPE(vector_TYPE* vec, TYPE val)$/;"	f	signature:(vector_TYPE* vec, TYPE val)
set_val_cap_TYPE	vector_template.h	/^void set_val_cap_TYPE(vector_TYPE* vec, TYPE val);$/;"	p	signature:(vector_TYPE* vec, TYPE val)
set_val_cap_binding	vector_binding.c	/^void set_val_cap_binding(vector_binding* vec, binding val)$/;"	f	signature:(vector_binding* vec, binding val)
set_val_cap_binding	vector_binding.h	/^void set_val_cap_binding(vector_binding* vec, binding val);$/;"	p	signature:(vector_binding* vec, binding val)
set_val_cap_d	cvector.h	/^void set_val_cap_d(vector_d* vec, double val)$/;"	f	signature:(vector_d* vec, double val)
set_val_cap_d	cvector.h	/^void set_val_cap_d(vector_d* vec, double val);$/;"	p	signature:(vector_d* vec, double val)
set_val_cap_i	cvector.h	/^void set_val_cap_i(vector_i* vec, int val)$/;"	f	signature:(vector_i* vec, int val)
set_val_cap_i	cvector.h	/^void set_val_cap_i(vector_i* vec, int val);$/;"	p	signature:(vector_i* vec, int val)
set_val_cap_str	cvector.h	/^void set_val_cap_str(vector_str* vec, char* val)$/;"	f	signature:(vector_str* vec, char* val)
set_val_cap_str	cvector.h	/^void set_val_cap_str(vector_str* vec, char* val);$/;"	p	signature:(vector_str* vec, char* val)
set_val_cap_void	cvector.h	/^void set_val_cap_void(vector_void* vec, void* val)$/;"	f	signature:(vector_void* vec, void* val)
set_val_cap_void	cvector.h	/^void set_val_cap_void(vector_void* vec, void* val);$/;"	p	signature:(vector_void* vec, void* val)
set_val_sz_TYPE	vector_template.c	/^void set_val_sz_TYPE(vector_TYPE* vec, TYPE val)$/;"	f	signature:(vector_TYPE* vec, TYPE val)
set_val_sz_TYPE	vector_template.h	/^void set_val_sz_TYPE(vector_TYPE* vec, TYPE val);$/;"	p	signature:(vector_TYPE* vec, TYPE val)
set_val_sz_binding	vector_binding.c	/^void set_val_sz_binding(vector_binding* vec, binding val)$/;"	f	signature:(vector_binding* vec, binding val)
set_val_sz_binding	vector_binding.h	/^void set_val_sz_binding(vector_binding* vec, binding val);$/;"	p	signature:(vector_binding* vec, binding val)
set_val_sz_d	cvector.h	/^void set_val_sz_d(vector_d* vec, double val)$/;"	f	signature:(vector_d* vec, double val)
set_val_sz_d	cvector.h	/^void set_val_sz_d(vector_d* vec, double val);$/;"	p	signature:(vector_d* vec, double val)
set_val_sz_i	cvector.h	/^void set_val_sz_i(vector_i* vec, int val)$/;"	f	signature:(vector_i* vec, int val)
set_val_sz_i	cvector.h	/^void set_val_sz_i(vector_i* vec, int val);$/;"	p	signature:(vector_i* vec, int val)
set_val_sz_str	cvector.h	/^void set_val_sz_str(vector_str* vec, char* val)$/;"	f	signature:(vector_str* vec, char* val)
set_val_sz_str	cvector.h	/^void set_val_sz_str(vector_str* vec, char* val);$/;"	p	signature:(vector_str* vec, char* val)
set_val_sz_void	cvector.h	/^void set_val_sz_void(vector_void* vec, void* val)$/;"	f	signature:(vector_void* vec, void* val)
set_val_sz_void	cvector.h	/^void set_val_sz_void(vector_void* vec, void* val);$/;"	p	signature:(vector_void* vec, void* val)
short_val	parser.h	/^		short short_val;$/;"	m	union:var_value::__anon3	access:public
size	cvector.h	/^	size_t size;             \/**< Current size (amount you should use when manipulating array directly). *\/$/;"	m	struct:vector_void	access:public
size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_d	access:public
size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_i	access:public
size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_str	access:public
size	vector_binding.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_binding	access:public
size	vector_template.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_TYPE	access:public
slice_c_array	c_utils.c	/^c_array slice_c_array(c_array array, int start, int end)$/;"	f	signature:(c_array array, int start, int end)
slice_c_array	c_utils.h	/^c_array slice_c_array(c_array array, int start, int end);$/;"	p	signature:(c_array array, int start, int end)
sort_date	stats/sortable.js	/^function sort_date(date) {	$/;"	f
sort_list	clist.h	/^void sort_list(list_head* head, int cmp(list_head*, list_head*))$/;"	f	signature:(list_head* head, int cmp(list_head*, list_head*))
sort_list	clist.h	/^void sort_list(list_head* head, int cmp(list_head*, list_head*));$/;"	p	signature:(list_head* head, int cmp(list_head*, list_head*))
sortables_init	stats/sortable.js	/^function sortables_init() {$/;"	f
split	c_utils.c	/^int split(c_array* array, byte* delim, size_t delim_len, c_array* out)$/;"	f	signature:(c_array* array, byte* delim, size_t delim_len, c_array* out)
split	c_utils.h	/^int split(c_array* in, byte* delim, size_t delim_len, c_array* out);$/;"	p	signature:(c_array* in, byte* delim, size_t delim_len, c_array* out)
statement	parser.h	/^typedef struct statement$/;"	s
statement	parser.h	/^} statement;$/;"	t	typeref:struct:statement
statement::bindings	parser.h	/^	vector_void* bindings;$/;"	m	struct:statement	access:public
statement::case_val	parser.h	/^	int case_val;$/;"	m	struct:statement	access:public
statement::exp	parser.h	/^	expression* exp;$/;"	m	struct:statement	access:public
statement::jump_to	parser.h	/^	size_t jump_to;$/;"	m	struct:statement	access:public
statement::lvalue	parser.h	/^	char* lvalue;$/;"	m	struct:statement	access:public
statement::parent	parser.h	/^	long parent;$/;"	m	struct:statement	access:public
statement::type	parser.h	/^	stmt_type type;$/;"	m	struct:statement	access:public
statement::vtype	parser.h	/^	var_type vtype;$/;"	m	struct:statement	access:public
statement_rule	parser.c	/^void statement_rule(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
statement_rule	parser.h	/^void statement_rule(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
stmt_list	parser.h	/^	vector_void stmt_list;$/;"	m	struct:function	access:public
stmt_list	parser.h	/^	vector_void* stmt_list;$/;"	m	struct:program_state	access:public
stmt_type	parser.h	/^} stmt_type;$/;"	t	typeref:enum:__anon5
string_db	parser.h	/^	vector_str string_db;$/;"	m	struct:program_state	access:public
switch_stmt	parser.c	/^void switch_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
switch_stmt	parser.h	/^void switch_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
symbol	parser.h	/^typedef struct symbol$/;"	s
symbol	parser.h	/^} symbol;$/;"	t	typeref:struct:symbol
symbol::cur_parent	parser.h	/^	int cur_parent;$/;"	m	struct:symbol	access:public
symbol::head	parser.h	/^	list_head head;$/;"	m	struct:symbol	access:public
symbol::name	parser.h	/^	char* name;$/;"	m	struct:symbol	access:public
symbols	parser.h	/^	vector_void symbols;$/;"	m	struct:function	access:public
test_func_in_block	tests/experimenting.c	/^	void test_func_in_block()$/;"	f
test_function	tests/experimenting.c	/^int* test_function()$/;"	f
test_ret	tests/experimenting.c	/^int test_ret()$/;"	f
thead	stats/sortable.js	/^var thead = false;$/;"	v
tok	parser.h	/^	token_value tok;$/;"	m	struct:expression	access:public
token_value	parser.h	/^typedef struct token_value$/;"	s
token_value	parser.h	/^} token_value;$/;"	t	typeref:struct:token_value
token_value::__anon4::id	parser.h	/^		char* id;$/;"	m	union:token_value::__anon4	access:public
token_value::__anon4::integer	parser.h	/^		int integer;$/;"	m	union:token_value::__anon4	access:public
token_value::__anon4::real	parser.h	/^		double real;$/;"	m	union:token_value::__anon4	access:public
token_value::type	parser.h	/^	Token type;$/;"	m	struct:token_value	access:public
token_value::v	parser.h	/^	} v;$/;"	m	struct:token_value	typeref:union:token_value::__anon4	access:public
tokens	parser.h	/^	vector_void tokens;$/;"	m	struct:parsing_state	access:public
top_level_declaration	parser.c	/^void top_level_declaration(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
top_level_declaration	parser.h	/^void top_level_declaration(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
translation_unit	parser.c	/^void translation_unit(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
translation_unit	parser.h	/^void translation_unit(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
trim	c_utils.c	/^char* trim(char* str)$/;"	f	signature:(char* str)
trim	c_utils.h	/^char* trim(char* str);$/;"	p	signature:(char* str)
trim	stats/sortable.js	/^function trim(s) {$/;"	f
ts_getInnerText	stats/sortable.js	/^function ts_getInnerText(el) {$/;"	f
ts_makeSortable	stats/sortable.js	/^function ts_makeSortable(t) {$/;"	f
ts_resortTable	stats/sortable.js	/^function ts_resortTable(lnk, clid) {$/;"	f
ts_sort_caseinsensitive	stats/sortable.js	/^function ts_sort_caseinsensitive(a,b) {$/;"	f
ts_sort_date	stats/sortable.js	/^function ts_sort_date(a,b) {$/;"	f
ts_sort_default	stats/sortable.js	/^function ts_sort_default(a,b) {$/;"	f
ts_sort_numeric	stats/sortable.js	/^function ts_sort_numeric(a,b) {$/;"	f
type	parser.h	/^	Token type;$/;"	m	struct:token_value	access:public
type	parser.h	/^	stmt_type type;$/;"	m	struct:statement	access:public
type	parser.h	/^	var_type type;$/;"	m	struct:var_value	access:public
u8	cvector.h	/^typedef unsigned char u8;$/;"	t
uchar_val	parser.h	/^		unsigned char uchar_val;$/;"	m	union:var_value::__anon3	access:public
uint_val	parser.h	/^		unsigned int uint_val;$/;"	m	union:var_value::__anon3	access:public
ulong_val	parser.h	/^		unsigned long ulong_val;$/;"	m	union:var_value::__anon3	access:public
unary_expr	parser.c	/^void unary_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
unary_expr	parser.h	/^void unary_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
used	parser.h	/^	size_t used;$/;"	m	struct:expr_block	access:public
ushort_val	parser.h	/^		unsigned short ushort_val;$/;"	m	union:var_value::__anon3	access:public
v	parser.h	/^	} v;$/;"	m	struct:token_value	typeref:union:token_value::__anon4	access:public
v	parser.h	/^	} v;$/;"	m	struct:var_value	typeref:union:var_value::__anon3	access:public
val	parser.h	/^	int val;$/;"	m	struct:a_case	access:public
val	parser.h	/^	var_value val;$/;"	m	struct:active_binding	access:public
var_type	parser.h	/^} var_type;$/;"	t	typeref:enum:__anon2
var_value	parser.h	/^typedef struct var_value$/;"	s
var_value	parser.h	/^} var_value;$/;"	t	typeref:struct:var_value
var_value::__anon3::char_val	parser.h	/^		char char_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::double_val	parser.h	/^		double double_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::float_val	parser.h	/^		float float_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::func_loc	parser.h	/^		unsigned int func_loc; \/\/change to direct pointer?$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::int_val	parser.h	/^		int int_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::long_val	parser.h	/^		long long_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::ptr	parser.h	/^		unsigned int ptr;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::short_val	parser.h	/^		short short_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::uchar_val	parser.h	/^		unsigned char uchar_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::uint_val	parser.h	/^		unsigned int uint_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::ulong_val	parser.h	/^		unsigned long ulong_val;$/;"	m	union:var_value::__anon3	access:public
var_value::__anon3::ushort_val	parser.h	/^		unsigned short ushort_val;$/;"	m	union:var_value::__anon3	access:public
var_value::type	parser.h	/^	var_type type;$/;"	m	struct:var_value	access:public
var_value::v	parser.h	/^	} v;$/;"	m	struct:var_value	typeref:union:var_value::__anon3	access:public
vec_TYPE	vector_template.c	/^int vec_TYPE(vector_TYPE* vec, size_t size, size_t capacity)$/;"	f	signature:(vector_TYPE* vec, size_t size, size_t capacity)
vec_TYPE	vector_template.h	/^int vec_TYPE(vector_TYPE* vec, size_t size, size_t capacity);$/;"	p	signature:(vector_TYPE* vec, size_t size, size_t capacity)
vec_TYPE_copy	vector_template.c	/^void vec_TYPE_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_TYPE_copy	vector_template.h	/^void vec_TYPE_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_TYPE_heap	vector_template.c	/^vector_TYPE* vec_TYPE_heap(size_t size, size_t capacity)$/;"	f	signature:(size_t size, size_t capacity)
vec_TYPE_heap	vector_template.h	/^vector_TYPE* vec_TYPE_heap(size_t size, size_t capacity);$/;"	p	signature:(size_t size, size_t capacity)
vec_binding	vector_binding.c	/^int vec_binding(vector_binding* vec, size_t size, size_t capacity)$/;"	f	signature:(vector_binding* vec, size_t size, size_t capacity)
vec_binding	vector_binding.h	/^int vec_binding(vector_binding* vec, size_t size, size_t capacity);$/;"	p	signature:(vector_binding* vec, size_t size, size_t capacity)
vec_binding_copy	vector_binding.c	/^void vec_binding_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_binding_copy	vector_binding.h	/^void vec_binding_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_binding_heap	vector_binding.c	/^vector_binding* vec_binding_heap(size_t size, size_t capacity)$/;"	f	signature:(size_t size, size_t capacity)
vec_binding_heap	vector_binding.h	/^vector_binding* vec_binding_heap(size_t size, size_t capacity);$/;"	p	signature:(size_t size, size_t capacity)
vec_d	cvector.h	/^int vec_d(vector_d* vec, size_t size, size_t capacity)$/;"	f	signature:(vector_d* vec, size_t size, size_t capacity)
vec_d	cvector.h	/^int vec_d(vector_d* vec, size_t size, size_t capacity);$/;"	p	signature:(vector_d* vec, size_t size, size_t capacity)
vec_d_copy	cvector.h	/^void vec_d_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_d_copy	cvector.h	/^void vec_d_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_d_heap	cvector.h	/^vector_d* vec_d_heap(size_t size, size_t capacity)$/;"	f	signature:(size_t size, size_t capacity)
vec_d_heap	cvector.h	/^vector_d* vec_d_heap(size_t size, size_t capacity);$/;"	p	signature:(size_t size, size_t capacity)
vec_i	cvector.h	/^int vec_i(vector_i* vec, size_t size, size_t capacity)$/;"	f	signature:(vector_i* vec, size_t size, size_t capacity)
vec_i	cvector.h	/^int vec_i(vector_i* vec, size_t size, size_t capacity);$/;"	p	signature:(vector_i* vec, size_t size, size_t capacity)
vec_i_copy	cvector.h	/^void vec_i_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_i_copy	cvector.h	/^void vec_i_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_i_heap	cvector.h	/^vector_i* vec_i_heap(size_t size, size_t capacity)$/;"	f	signature:(size_t size, size_t capacity)
vec_i_heap	cvector.h	/^vector_i* vec_i_heap(size_t size, size_t capacity);$/;"	p	signature:(size_t size, size_t capacity)
vec_str	cvector.h	/^int vec_str(vector_str* vec, size_t size, size_t capacity)$/;"	f	signature:(vector_str* vec, size_t size, size_t capacity)
vec_str	cvector.h	/^int vec_str(vector_str* vec, size_t size, size_t capacity);$/;"	p	signature:(vector_str* vec, size_t size, size_t capacity)
vec_str_copy	cvector.h	/^void vec_str_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_str_copy	cvector.h	/^void vec_str_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_str_heap	cvector.h	/^vector_str* vec_str_heap(size_t size, size_t capacity)$/;"	f	signature:(size_t size, size_t capacity)
vec_str_heap	cvector.h	/^vector_str* vec_str_heap(size_t size, size_t capacity);$/;"	p	signature:(size_t size, size_t capacity)
vec_void	cvector.h	/^int vec_void(vector_void* vec, size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(vector_void* vec, size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vec_void	cvector.h	/^int vec_void(vector_void* vec, size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(vector_void* vec, size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vec_void_copy	cvector.h	/^void vec_void_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_void_copy	cvector.h	/^void vec_void_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_void_get	cvector.h	/^void* vec_void_get(vector_void* vec, size_t i)$/;"	f	signature:(vector_void* vec, size_t i)
vec_void_get	cvector.h	/^void* vec_void_get(vector_void* vec, size_t i);$/;"	p	signature:(vector_void* vec, size_t i)
vec_void_heap	cvector.h	/^vector_void* vec_void_heap(size_t size, size_t capacity, size_t elem_sz, void (*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(size_t size, size_t capacity, size_t elem_sz, void (*elem_free)(void*), void(*elem_init)(void*, void*))
vec_void_heap	cvector.h	/^vector_void* vec_void_heap(size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vector_TYPE	vector_template.h	/^typedef struct vector_TYPE$/;"	s
vector_TYPE	vector_template.h	/^} vector_TYPE;$/;"	t	typeref:struct:vector_TYPE
vector_TYPE::a	vector_template.h	/^	TYPE* a;           \/**< Array. *\/$/;"	m	struct:vector_TYPE	access:public
vector_TYPE::capacity	vector_template.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_TYPE	access:public
vector_TYPE::size	vector_template.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_TYPE	access:public
vector_binding	vector_binding.h	/^typedef struct vector_binding$/;"	s
vector_binding	vector_binding.h	/^} vector_binding;$/;"	t	typeref:struct:vector_binding
vector_binding::a	vector_binding.h	/^	binding* a;           \/**< Array. *\/$/;"	m	struct:vector_binding	access:public
vector_binding::capacity	vector_binding.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_binding	access:public
vector_binding::size	vector_binding.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_binding	access:public
vector_d	cvector.h	/^typedef struct vector_d$/;"	s
vector_d	cvector.h	/^} vector_d;$/;"	t	typeref:struct:vector_d
vector_d::a	cvector.h	/^	double* a;         \/**< Array. *\/$/;"	m	struct:vector_d	access:public
vector_d::capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_d	access:public
vector_d::size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_d	access:public
vector_i	cvector.h	/^typedef struct vector_i$/;"	s
vector_i	cvector.h	/^} vector_i;$/;"	t	typeref:struct:vector_i
vector_i::a	cvector.h	/^	int* a;            \/**< Array. *\/$/;"	m	struct:vector_i	access:public
vector_i::capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_i	access:public
vector_i::size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_i	access:public
vector_str	cvector.h	/^typedef struct vector_str$/;"	s
vector_str	cvector.h	/^} vector_str;$/;"	t	typeref:struct:vector_str
vector_str::a	cvector.h	/^	char** a;          \/**< Array. *\/$/;"	m	struct:vector_str	access:public
vector_str::capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_str	access:public
vector_str::size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_str	access:public
vector_void	cvector.h	/^typedef struct vector_void$/;"	s
vector_void	cvector.h	/^} vector_void;$/;"	t	typeref:struct:vector_void
vector_void::a	cvector.h	/^	u8* a;                 \/**< Array. *\/$/;"	m	struct:vector_void	access:public
vector_void::capacity	cvector.h	/^	size_t capacity;         \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_void	access:public
vector_void::elem_free	cvector.h	/^	void (*elem_free)(void*);$/;"	m	struct:vector_void	access:public
vector_void::elem_init	cvector.h	/^	void (*elem_init)(void*, void*);$/;"	m	struct:vector_void	access:public
vector_void::elem_size	cvector.h	/^	size_t elem_size;        \/**< Size in u8s of type stored (sizeof(T) where T is type). *\/$/;"	m	struct:vector_void	access:public
vector_void::size	cvector.h	/^	size_t size;             \/**< Current size (amount you should use when manipulating array directly). *\/$/;"	m	struct:vector_void	access:public
vtype	parser.h	/^	var_type vtype;$/;"	m	struct:binding	access:public
vtype	parser.h	/^	var_type vtype;$/;"	m	struct:statement	access:public
weekly_activity	stats/activity.html	/^<h2><a href="#weekly_activity" name="weekly_activity">Weekly activity<\/a><\/h2>$/;"	a
while_stmt	parser.c	/^void while_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
while_stmt	parser.h	/^void while_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
