!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADD	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
ADDEQUAL	lexer.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:Token
BASIC_TYPES	basic_types.h	2;"	d
BINARY_OP	interpreter.h	160;"	d
BIT_AND	lexer.h	/^	LEFT_SHIFT, RIGHT_SHIFT, BIT_AND, BIT_OR, BIT_XOR,$/;"	e	enum:Token
BIT_AND_EQUAL	lexer.h	/^	LSHIFT_EQUAL, RSHIFT_EQUAL, BIT_AND_EQUAL, BIT_OR_EQUAL, BIT_XOR_EQUAL,$/;"	e	enum:Token
BIT_NEGATION	lexer.h	/^	BIT_NEGATION,$/;"	e	enum:Token
BIT_OR	lexer.h	/^	LEFT_SHIFT, RIGHT_SHIFT, BIT_AND, BIT_OR, BIT_XOR,$/;"	e	enum:Token
BIT_OR_EQUAL	lexer.h	/^	LSHIFT_EQUAL, RSHIFT_EQUAL, BIT_AND_EQUAL, BIT_OR_EQUAL, BIT_XOR_EQUAL,$/;"	e	enum:Token
BIT_XOR	lexer.h	/^	LEFT_SHIFT, RIGHT_SHIFT, BIT_AND, BIT_OR, BIT_XOR,$/;"	e	enum:Token
BIT_XOR_EQUAL	lexer.h	/^	LSHIFT_EQUAL, RSHIFT_EQUAL, BIT_AND_EQUAL, BIT_OR_EQUAL, BIT_XOR_EQUAL,$/;"	e	enum:Token
BOTH	parser.h	/^	BOTH$/;"	e	enum:__anon4
BREAK	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
BREAK_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon3
CASE	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
CASE_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon3
CHAR	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
CHAR_LITERAL	lexer.h	/^	INT_LITERAL, FLOAT_LITERAL, DOUBLE_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:Token
CHAR_TYPE	parser.h	/^	CHAR_TYPE, \/* implementation defined whether plain char is signed or not ...*\/$/;"	e	enum:__anon1
CLEAR_SCREEN	c_utils.h	75;"	d
CLIST_H	clist.h	2;"	d
COLON	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
COMMA	lexer.h	/^	EQUAL, COMMA, LBRACKET, RBRACKET, LBRACE, RBRACE, TERNARY,$/;"	e	enum:Token
COMMA_OP	interpreter.h	1165;"	d
COND_EXPR	interpreter.h	1125;"	d
CONTINUE	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
CONTINUE_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon3
CSTR_ST_SZ	rsw_cstr.c	/^size_t CSTR_ST_SZ = 25;$/;"	v
CVECTOR_H	cvector.h	4;"	d
CVECTOR_IMPLEMENTATION	parser.c	5;"	d	file:
C_UTILS	c_utils.h	2;"	d
DECLARATION	lexer.h	/^	DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:Token
DECL_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon3
DECREMENT	lexer.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:Token
DEFAULT	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
DEFAULT_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon3
DIV	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
DIVEQUAL	lexer.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:Token
DO	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
DOT	lexer.h	/^	DOT, INDIRECTION,$/;"	e	enum:Token
DOUBLE	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
DOUBLE_LITERAL	lexer.h	/^	INT_LITERAL, FLOAT_LITERAL, DOUBLE_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:Token
DOUBLE_TYPE	parser.h	/^	DOUBLE_TYPE,$/;"	e	enum:__anon1
DO_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon3
ELSE	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
END	lexer.h	/^	END,$/;"	e	enum:Token
END_COMPOUND_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon3
EQUAL	lexer.h	/^	EQUAL, COMMA, LBRACKET, RBRACKET, LBRACE, RBRACE, TERNARY,$/;"	e	enum:Token
EQUALEQUAL	lexer.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:Token
EXP	lexer.h	/^	DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:Token
EXPR_LIST	lexer.h	/^	DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:Token
EXPR_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon3
FLOAT	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
FLOAT_LITERAL	lexer.h	/^	INT_LITERAL, FLOAT_LITERAL, DOUBLE_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:Token
FLOAT_TYPE	parser.h	/^	FLOAT_TYPE,$/;"	e	enum:__anon1
FOR	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
FOR_STMT	parser.h	/^	FOR_STMT, CONTINUE_STMT, BREAK_STMT, DO_STMT, CASE_STMT, DEFAULT_STMT,$/;"	e	enum:__anon3
FUNCTION_TYPE	parser.h	/^	FUNCTION_TYPE,$/;"	e	enum:__anon1
FUNC_CALL	lexer.h	/^	DECLARATION, EXP, EXPR_LIST, FUNC_CALL,$/;"	e	enum:Token
GET_BINDING	parser.h	20;"	d
GET_FUNCTION	parser.h	18;"	d
GET_PARAM	preprocessor.h	15;"	d
GET_STMT	parser.h	17;"	d
GET_SYMBOL	parser.h	19;"	d
GET_VAR_VALUE	parser.h	72;"	d
GET_VOID	cvector.h	139;"	d
GOTO	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
GOTO_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon3
GREATER	lexer.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:Token
GTEQ	lexer.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:Token
HANDLE_BACKSLASH	lexer.c	12;"	d	file:
HANDLE_BACKSLASH_STR	lexer.c	422;"	d	file:
ID	lexer.h	/^	ID,$/;"	e	enum:Token
IF	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
IF_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon3
INCREMENT	lexer.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:Token
INDIRECTION	lexer.h	/^	DOT, INDIRECTION,$/;"	e	enum:Token
INIT_LIST_HEAD	clist.h	/^static inline void INIT_LIST_HEAD(list_head *list)$/;"	f	signature:(list_head *list)
INT	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
INTEGRAL_BINARY_OP	interpreter.h	739;"	d
INTERPRETER_H	interpreter.h	2;"	d
INT_LITERAL	lexer.h	/^	INT_LITERAL, FLOAT_LITERAL, DOUBLE_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:Token
INT_MAX_LEN	c_utils.h	116;"	d
INT_PTR_TYPE	parser.h	/^	INT_PTR_TYPE$/;"	e	enum:__anon1
INT_TYPE	parser.h	/^	INT_TYPE,$/;"	e	enum:__anon1
LBRACE	lexer.h	/^	EQUAL, COMMA, LBRACKET, RBRACKET, LBRACE, RBRACE, TERNARY,$/;"	e	enum:Token
LBRACKET	lexer.h	/^	EQUAL, COMMA, LBRACKET, RBRACKET, LBRACE, RBRACE, TERNARY,$/;"	e	enum:Token
LEFT_SHIFT	lexer.h	/^	LEFT_SHIFT, RIGHT_SHIFT, BIT_AND, BIT_OR, BIT_XOR,$/;"	e	enum:Token
LESS	lexer.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:Token
LEXER_H	lexer.h	2;"	d
LIST_HEAD	clist.h	13;"	d
LIST_HEAD_INIT	clist.h	11;"	d
LOGICAL_AND	lexer.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:Token
LOGICAL_NEGATION	lexer.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:Token
LOGICAL_OR	lexer.h	/^	LOGICAL_OR, LOGICAL_AND, LOGICAL_NEGATION, INCREMENT, DECREMENT,$/;"	e	enum:Token
LONG	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
LONG_TYPE	parser.h	/^	LONG_TYPE,$/;"	e	enum:__anon1
LPAREN	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
LSHIFT_EQUAL	lexer.h	/^	LSHIFT_EQUAL, RSHIFT_EQUAL, BIT_AND_EQUAL, BIT_OR_EQUAL, BIT_XOR_EQUAL,$/;"	e	enum:Token
LTEQ	lexer.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:Token
MAX_MACRO_LEN	preprocessor.c	10;"	d	file:
MAX_TOKEN_LEN	lexer.h	7;"	d
MOD	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
MODEQUAL	lexer.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:Token
MULT	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
MULTEQUAL	lexer.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:Token
NOTEQUAL	lexer.h	/^	EQUALEQUAL, GREATER, GTEQ, LESS, LTEQ, NOTEQUAL,$/;"	e	enum:Token
NULL_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon3
ONLY_GLOBAL	parser.h	/^	ONLY_GLOBAL,$/;"	e	enum:__anon4
ONLY_LOCAL	parser.h	/^	ONLY_LOCAL,$/;"	e	enum:__anon4
PARSER_H	parser.h	2;"	d
PARSING	lexer.h	8;"	d
POST_DECREMENT	lexer.h	/^	POST_INCREMENT, POST_DECREMENT, PRE_INCREMENT, PRE_DECREMENT$/;"	e	enum:Token
POST_INCREMENT	lexer.h	/^	POST_INCREMENT, POST_DECREMENT, PRE_INCREMENT, PRE_DECREMENT$/;"	e	enum:Token
POST_OP	interpreter.h	108;"	d
POUND	lexer.h	/^	POUND, \/\/only used in preprocessor$/;"	e	enum:Token
PREPROCESSOR_H	preprocessor.h	2;"	d
PRE_DECREMENT	lexer.h	/^	POST_INCREMENT, POST_DECREMENT, PRE_INCREMENT, PRE_DECREMENT$/;"	e	enum:Token
PRE_INCREMENT	lexer.h	/^	POST_INCREMENT, POST_DECREMENT, PRE_INCREMENT, PRE_DECREMENT$/;"	e	enum:Token
PRE_OP	interpreter.h	68;"	d
PRINT	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
PRINT_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon3
RBRACE	lexer.h	/^	EQUAL, COMMA, LBRACKET, RBRACKET, LBRACE, RBRACE, TERNARY,$/;"	e	enum:Token
RBRACKET	lexer.h	/^	EQUAL, COMMA, LBRACKET, RBRACKET, LBRACE, RBRACE, TERNARY,$/;"	e	enum:Token
READ_STRING	c_utils.h	54;"	d
RETURN	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
RETURN_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon3
RIGHT_SHIFT	lexer.h	/^	LEFT_SHIFT, RIGHT_SHIFT, BIT_AND, BIT_OR, BIT_XOR,$/;"	e	enum:Token
RPAREN	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
RSHIFT_EQUAL	lexer.h	/^	LSHIFT_EQUAL, RSHIFT_EQUAL, BIT_AND_EQUAL, BIT_OR_EQUAL, BIT_XOR_EQUAL,$/;"	e	enum:Token
RSW_CSTR_ALLOCATOR	rsw_cstr.c	10;"	d	file:
RSW_CSTR_H	rsw_cstr.h	2;"	d
SEMICOLON	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
SET_CSTR	rsw_cstr.h	19;"	d
SET_C_ARRAY	c_utils.h	21;"	d
SHORT	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
SHORT_TYPE	parser.h	/^	SHORT_TYPE,$/;"	e	enum:__anon1
SIGNED	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
SPACE_SET	c_utils.h	79;"	d
SPACE_SET_NO_NEWLINE	c_utils.h	80;"	d
START_COMPOUND_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon3
STDERR	rsw_cstr.c	8;"	d	file:
STDERR	vector_token_lex.h	65;"	d
STR_LITERAL	lexer.h	/^	INT_LITERAL, FLOAT_LITERAL, DOUBLE_LITERAL, CHAR_LITERAL, STR_LITERAL,$/;"	e	enum:Token
SUB	lexer.h	/^	MOD, LPAREN, RPAREN, MULT, ADD, SUB, DIV, COLON, SEMICOLON,$/;"	e	enum:Token
SUBEQUAL	lexer.h	/^	ADDEQUAL, SUBEQUAL, MULTEQUAL, DIVEQUAL, MODEQUAL,$/;"	e	enum:Token
SWITCH	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
SWITCH_STMT	parser.h	/^	SWITCH_STMT, DECL_STMT, RETURN_STMT, START_COMPOUND_STMT, END_COMPOUND_STMT$/;"	e	enum:__anon3
TERNARY	lexer.h	/^	EQUAL, COMMA, LBRACKET, RBRACKET, LBRACE, RBRACE, TERNARY,$/;"	e	enum:Token
Token	lexer.h	/^typedef enum Token$/;"	g
Token	lexer.h	/^} Token;$/;"	t	typeref:enum:Token
UCHAR_TYPE	parser.h	/^	UCHAR_TYPE,$/;"	e	enum:__anon1
UINT_TYPE	parser.h	/^	UINT_TYPE,$/;"	e	enum:__anon1
ULONG_TYPE	parser.h	/^	ULONG_TYPE,$/;"	e	enum:__anon1
UNKNOWN	parser.h	/^	UNKNOWN = 0,$/;"	e	enum:__anon1
UNSIGNED	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
USHORT_TYPE	parser.h	/^	USHORT_TYPE,$/;"	e	enum:__anon1
VECTOR_token_lex_H	vector_token_lex.h	2;"	d
VECTOR_token_lex_IMPLEMENTATION	parser.c	8;"	d	file:
VEC_D_ALLOCATOR	cvector.h	430;"	d
VEC_D_START_SZ	cvector.h	/^size_t VEC_D_START_SZ = 50;$/;"	v
VEC_I_ALLOCATOR	cvector.h	180;"	d
VEC_I_START_SZ	cvector.h	/^size_t VEC_I_START_SZ = 50;$/;"	v
VEC_STR_ALLOCATOR	cvector.h	679;"	d
VEC_STR_START_SZ	cvector.h	/^size_t VEC_STR_START_SZ = 20;$/;"	v
VEC_VOID_ALLOCATOR	cvector.h	999;"	d
VEC_VOID_START_SZ	cvector.h	/^size_t VEC_VOID_START_SZ = 20;$/;"	v
VEC_token_lex_ALLOCATOR	vector_token_lex.h	71;"	d
VEC_token_lex_SZ	vector_token_lex.h	/^size_t VEC_token_lex_SZ = 20;$/;"	v
VOID	lexer.h	/^	INT, SHORT, LONG, FLOAT, DOUBLE, CHAR, VOID, SIGNED, UNSIGNED,$/;"	e	enum:Token
VOID_TYPE	parser.h	/^	VOID_TYPE,$/;"	e	enum:__anon1
WHILE	lexer.h	/^	DO, WHILE, FOR, PRINT, IF, ELSE, SWITCH, CASE, DEFAULT, CONTINUE, BREAK, GOTO, RETURN,$/;"	e	enum:Token
WHILE_STMT	parser.h	/^	NULL_STMT = 0, WHILE_STMT, PRINT_STMT, EXPR_STMT, IF_STMT, GOTO_STMT,$/;"	e	enum:__anon3
__list_add	clist.h	/^static inline void __list_add(list_head* item, list_head* prev, list_head* next)$/;"	f	signature:(list_head* item, list_head* prev, list_head* next)
__list_del	clist.h	/^static inline void __list_del(list_head* prev, list_head* next)$/;"	f	signature:(list_head* prev, list_head* next)
__list_for_each	clist.h	130;"	d
a	cvector.h	/^	char** a;          \/**< Array. *\/$/;"	m	struct:vector_str	access:public
a	cvector.h	/^	double* a;         \/**< Array. *\/$/;"	m	struct:vector_d	access:public
a	cvector.h	/^	int* a;            \/**< Array. *\/$/;"	m	struct:vector_i	access:public
a	cvector.h	/^	u8* a;                 \/**< Array. *\/$/;"	m	struct:vector_void	access:public
a	rsw_cstr.h	/^	char* a;           \/**< Array. *\/$/;"	m	struct:rsw_cstr	access:public
a	vector_token_lex.h	/^	token_lex* a;$/;"	m	struct:vector_token_lex	access:public
a_case	parser.h	/^typedef struct a_case$/;"	s
a_case	parser.h	/^} a_case;$/;"	t	typeref:struct:a_case
a_case::jump_to	parser.h	/^	unsigned int jump_to;$/;"	m	struct:a_case	access:public
a_case::val	parser.h	/^	int val;$/;"	m	struct:a_case	access:public
active_binding	parser.h	/^typedef struct active_binding$/;"	s
active_binding	parser.h	/^} active_binding;$/;"	t	typeref:struct:active_binding
active_binding::list	parser.h	/^	list_head list;$/;"	m	struct:active_binding	access:public
active_binding::parent	parser.h	/^	int parent;$/;"	m	struct:active_binding	access:public
active_binding::val	parser.h	/^	var_value val;$/;"	m	struct:active_binding	access:public
add_binding	interpreter.c	/^void add_binding(program_state* prog, char* name, var_type vtype)$/;"	f	signature:(program_state* prog, char* name, var_type vtype)
add_binding	interpreter.h	/^void add_binding(program_state* prog, char* name, var_type vtype);$/;"	p	signature:(program_state* prog, char* name, var_type vtype)
add_binding	parser.h	/^void add_binding(program_state* prog, char* name, var_type vtype);$/;"	p	signature:(program_state* prog, char* name, var_type vtype)
add_expr	parser.c	/^void add_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
add_expr	parser.h	/^void add_expr(parsing_state* p, program_state* prog, expression* exp);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* exp)
all	c_utils.c	/^int all(c_array* array, int (*is_true)(const void*))$/;"	f	signature:(c_array* array, int (*is_true)(const void*))
all	c_utils.h	/^int all(c_array* array, int (*is_true)(const void*));$/;"	p	signature:(c_array* array, int (*is_true)(const void*))
any	c_utils.c	/^int any(c_array* array, int (*is_true)(const void*))$/;"	f	signature:(c_array* array, int (*is_true)(const void*))
any	c_utils.h	/^int any(c_array* array, int (*is_true)(const void*));$/;"	p	signature:(c_array* array, int (*is_true)(const void*))
apply_scope	interpreter.c	/^void apply_scope(program_state* prog, int jump_to, int child, int parent)$/;"	f	signature:(program_state* prog, int jump_to, int child, int parent)
apply_scope	interpreter.h	/^void apply_scope(program_state* prog, int jump_to, int child, int parent);$/;"	p	signature:(program_state* prog, int jump_to, int child, int parent)
apply_scope	parser.h	/^void apply_scope(program_state* prog, int jump_to, int child, int parent);$/;"	p	signature:(program_state* prog, int jump_to, int child, int parent)
are_equal_char	c_utils.c	/^int are_equal_char(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_char	c_utils.h	/^int are_equal_char(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_double	c_utils.c	/^int are_equal_double(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_double	c_utils.h	/^int are_equal_double(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_float	c_utils.c	/^int are_equal_float(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_float	c_utils.h	/^int are_equal_float(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_int	c_utils.c	/^int are_equal_int(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_int	c_utils.h	/^int are_equal_int(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_long	c_utils.c	/^int are_equal_long(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_long	c_utils.h	/^int are_equal_long(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_short	c_utils.c	/^int are_equal_short(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_short	c_utils.h	/^int are_equal_short(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_string	c_utils.c	/^int are_equal_string(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_string	c_utils.h	/^int are_equal_string(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_uchar	c_utils.c	/^int are_equal_uchar(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_uchar	c_utils.h	/^int are_equal_uchar(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_uint	c_utils.c	/^int are_equal_uint(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_uint	c_utils.h	/^int are_equal_uint(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_ulong	c_utils.c	/^int are_equal_ulong(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_ulong	c_utils.h	/^int are_equal_ulong(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
are_equal_ushort	c_utils.c	/^int are_equal_ushort(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
are_equal_ushort	c_utils.h	/^int are_equal_ushort(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
assign_expr	parser.c	/^void assign_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
assign_expr	parser.h	/^void assign_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
assignment_operator	parser.c	/^int assignment_operator(Token tok)$/;"	f	signature:(Token tok)
back_d	cvector.h	/^double* back_d(vector_d* vec)$/;"	f	signature:(vector_d* vec)
back_d	cvector.h	/^double* back_d(vector_d* vec);$/;"	p	signature:(vector_d* vec)
back_i	cvector.h	/^int* back_i(vector_i* vec)$/;"	f	signature:(vector_i* vec)
back_i	cvector.h	/^int* back_i(vector_i* vec);$/;"	p	signature:(vector_i* vec)
back_str	cvector.h	/^char** back_str(vector_str* vec)$/;"	f	signature:(vector_str* vec)
back_str	cvector.h	/^char** back_str(vector_str* vec);$/;"	p	signature:(vector_str* vec)
back_token_lex	vector_token_lex.h	/^token_lex* back_token_lex(vector_token_lex* vec)$/;"	f	signature:(vector_token_lex* vec)
back_token_lex	vector_token_lex.h	/^token_lex* back_token_lex(vector_token_lex* vec);$/;"	p	signature:(vector_token_lex* vec)
back_void	cvector.h	/^void* back_void(vector_void* vec)$/;"	f	signature:(vector_void* vec)
back_void	cvector.h	/^void* back_void(vector_void* vec);$/;"	p	signature:(vector_void* vec)
binding	parser.h	/^typedef struct binding$/;"	s
binding	parser.h	/^} binding;$/;"	t	typeref:struct:binding
binding::decl_stmt	parser.h	/^	int decl_stmt;$/;"	m	struct:binding	access:public
binding::name	parser.h	/^	char* name;$/;"	m	struct:binding	access:public
binding::vtype	parser.h	/^	var_type vtype;$/;"	m	struct:binding	access:public
bindings	parser.h	/^	vector_void* bindings;$/;"	m	struct:program_state	access:public
bindings	parser.h	/^	vector_void* bindings;$/;"	m	struct:statement	access:public
bitwise_and_expr	parser.c	/^void bitwise_and_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
bitwise_and_expr	parser.h	/^void bitwise_and_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
bitwise_or_expr	parser.c	/^void bitwise_or_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
bitwise_or_expr	parser.h	/^void bitwise_or_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
bitwise_xor_expr	parser.c	/^void bitwise_xor_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
bitwise_xor_expr	parser.h	/^void bitwise_xor_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
break_or_continue_stmt	parser.c	/^void break_or_continue_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
break_or_continue_stmt	parser.h	/^void break_or_continue_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
byte	basic_types.h	/^typedef unsigned char byte;$/;"	t
c_array	c_utils.h	/^typedef struct c_array$/;"	s
c_array	c_utils.h	/^} c_array;$/;"	t	typeref:struct:c_array
c_array::data	c_utils.h	/^	byte* data;$/;"	m	struct:c_array	access:public
c_array::elem_size	c_utils.h	/^	size_t elem_size;$/;"	m	struct:c_array	access:public
c_array::len	c_utils.h	/^	size_t len;$/;"	m	struct:c_array	access:public
capacity	cvector.h	/^	size_t capacity;         \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_void	access:public
capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_d	access:public
capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_i	access:public
capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_str	access:public
capacity	rsw_cstr.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size + 1 (for '\\0'). *\/$/;"	m	struct:rsw_cstr	access:public
capacity	vector_token_lex.h	/^	size_t capacity;$/;"	m	struct:vector_token_lex	access:public
case_or_default_stmt	parser.c	/^void case_or_default_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
case_or_default_stmt	parser.h	/^void case_or_default_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
case_val	parser.h	/^	int case_val;$/;"	m	struct:statement	access:public
char_pos	lexer.h	/^	char* char_pos; \/\/location in overall file string (only used in read_token_from_str)$/;"	m	struct:token_lex	access:public
char_val	parser.h	/^		char char_val;$/;"	m	union:var_value::__anon2	access:public
clear_bindings	interpreter.c	/^void clear_bindings(program_state* prog)$/;"	f	signature:(program_state* prog)
clear_bindings	interpreter.h	/^void clear_bindings(program_state* prog);$/;"	p	signature:(program_state* prog)
clear_bindings	parser.h	/^void clear_bindings(program_state* prog);$/;"	p	signature:(program_state* prog)
clear_d	cvector.h	/^void clear_d(vector_d* vec) { vec->size = 0; }$/;"	f	signature:(vector_d* vec)
clear_d	cvector.h	/^void clear_d(vector_d* vec);$/;"	p	signature:(vector_d* vec)
clear_i	cvector.h	/^void clear_i(vector_i* vec) { vec->size = 0; }$/;"	f	signature:(vector_i* vec)
clear_i	cvector.h	/^void clear_i(vector_i* vec);$/;"	p	signature:(vector_i* vec)
clear_str	cvector.h	/^void clear_str(vector_str* vec)$/;"	f	signature:(vector_str* vec)
clear_str	cvector.h	/^void clear_str(vector_str* vec);$/;"	p	signature:(vector_str* vec)
clear_token_lex	vector_token_lex.h	/^void clear_token_lex(vector_token_lex* vec)$/;"	f	signature:(vector_token_lex* vec)
clear_token_lex	vector_token_lex.h	/^void clear_token_lex(vector_token_lex* vec);$/;"	p	signature:(vector_token_lex* vec)
clear_void	cvector.h	/^void clear_void(vector_void* vec)$/;"	f	signature:(vector_void* vec)
clear_void	cvector.h	/^void clear_void(vector_void* vec);$/;"	p	signature:(vector_void* vec)
comma_expr	parser.c	/^void comma_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
comma_expr	parser.h	/^void comma_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
compare_char	c_utils.c	/^int compare_char(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_char	c_utils.h	/^int compare_char(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_double	c_utils.c	/^int compare_double(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_double	c_utils.h	/^int compare_double(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_float	c_utils.c	/^int compare_float(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_float	c_utils.h	/^int compare_float(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_int	c_utils.c	/^int compare_int(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_int	c_utils.h	/^int compare_int(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_long	c_utils.c	/^int compare_long(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_long	c_utils.h	/^int compare_long(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_short	c_utils.c	/^int compare_short(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_short	c_utils.h	/^int compare_short(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_string	c_utils.c	/^int compare_string(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_string	c_utils.h	/^int compare_string(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_uchar	c_utils.c	/^int compare_uchar(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_uchar	c_utils.h	/^int compare_uchar(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_uint	c_utils.c	/^int compare_uint(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_uint	c_utils.h	/^int compare_uint(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_ulong	c_utils.c	/^int compare_ulong(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_ulong	c_utils.h	/^int compare_ulong(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compare_ushort	c_utils.c	/^int compare_ushort(const void* a, const void* b)$/;"	f	signature:(const void* a, const void* b)
compare_ushort	c_utils.h	/^int compare_ushort(const void* a, const void* b);$/;"	p	signature:(const void* a, const void* b)
compound_statement	parser.c	/^void compound_statement(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
compound_statement	parser.h	/^void compound_statement(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
cond_expr	parser.c	/^void cond_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
cond_expr	parser.h	/^void cond_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
container_of	clist.h	81;"	d
copy_c_array	c_utils.c	/^c_array copy_c_array(c_array src)$/;"	f	signature:(c_array src)
copy_c_array	c_utils.h	/^c_array copy_c_array(c_array src);$/;"	p	signature:(c_array src)
copy_expr	parser.c	/^expression* copy_expr(program_state* prog, expression* e)$/;"	f	signature:(program_state* prog, expression* e)
copy_expr	parser.h	/^expression* copy_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
cstr_clear	rsw_cstr.c	/^void cstr_clear(rsw_cstr* str) { str->size = 0; }$/;"	f	signature:(rsw_cstr* str)
cstr_clear	rsw_cstr.h	/^void cstr_clear(rsw_cstr* str);$/;"	p	signature:(rsw_cstr* str)
cstr_concatenate	rsw_cstr.c	/^int cstr_concatenate(rsw_cstr* str, char* a, size_t len)$/;"	f	signature:(rsw_cstr* str, char* a, size_t len)
cstr_concatenate	rsw_cstr.h	/^int cstr_concatenate(rsw_cstr* str, char* a, size_t len);$/;"	p	signature:(rsw_cstr* str, char* a, size_t len)
cstr_concatenate_cstr	rsw_cstr.c	/^int cstr_concatenate_cstr(rsw_cstr* str, rsw_cstr* a_str)$/;"	f	signature:(rsw_cstr* str, rsw_cstr* a_str)
cstr_concatenate_cstr	rsw_cstr.h	/^int cstr_concatenate_cstr(rsw_cstr* str, rsw_cstr* a_str);$/;"	p	signature:(rsw_cstr* str, rsw_cstr* a_str)
cstr_copy	rsw_cstr.c	/^void cstr_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
cstr_copy	rsw_cstr.h	/^void cstr_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
cstr_erase	rsw_cstr.c	/^void cstr_erase(rsw_cstr* str, size_t start, size_t end)$/;"	f	signature:(rsw_cstr* str, size_t start, size_t end)
cstr_erase	rsw_cstr.h	/^void cstr_erase(rsw_cstr* str, size_t start, size_t end);$/;"	p	signature:(rsw_cstr* str, size_t start, size_t end)
cstr_extend	rsw_cstr.c	/^int cstr_extend(rsw_cstr* str, size_t num, char a)$/;"	f	signature:(rsw_cstr* str, size_t num, char a)
cstr_extend	rsw_cstr.h	/^int cstr_extend(rsw_cstr* str, size_t num, char a);$/;"	p	signature:(rsw_cstr* str, size_t num, char a)
cstr_find	rsw_cstr.c	/^size_t cstr_find(rsw_cstr* str, rsw_cstr* needle)$/;"	f	signature:(rsw_cstr* str, rsw_cstr* needle)
cstr_find	rsw_cstr.h	/^size_t cstr_find(rsw_cstr* str, rsw_cstr* needle);$/;"	p	signature:(rsw_cstr* str, rsw_cstr* needle)
cstr_find_start_at	rsw_cstr.c	/^size_t cstr_find_start_at(rsw_cstr* str, rsw_cstr* needle, size_t start)$/;"	f	signature:(rsw_cstr* str, rsw_cstr* needle, size_t start)
cstr_find_start_at	rsw_cstr.h	/^size_t cstr_find_start_at(rsw_cstr* str, rsw_cstr* needle, size_t start);$/;"	p	signature:(rsw_cstr* str, rsw_cstr* needle, size_t start)
cstr_find_str	rsw_cstr.c	/^size_t cstr_find_str(rsw_cstr* str, char* needle)$/;"	f	signature:(rsw_cstr* str, char* needle)
cstr_find_str	rsw_cstr.h	/^size_t cstr_find_str(rsw_cstr* str, char* needle);$/;"	p	signature:(rsw_cstr* str, char* needle)
cstr_find_str_start_at	rsw_cstr.c	/^size_t cstr_find_str_start_at(rsw_cstr* str, char* needle, size_t start)$/;"	f	signature:(rsw_cstr* str, char* needle, size_t start)
cstr_find_str_start_at	rsw_cstr.h	/^size_t cstr_find_str_start_at(rsw_cstr* str, char* needle, size_t start);$/;"	p	signature:(rsw_cstr* str, char* needle, size_t start)
cstr_insert	rsw_cstr.c	/^int cstr_insert(rsw_cstr* str, size_t i, char a)$/;"	f	signature:(rsw_cstr* str, size_t i, char a)
cstr_insert	rsw_cstr.h	/^int cstr_insert(rsw_cstr* str, size_t i, char a);$/;"	p	signature:(rsw_cstr* str, size_t i, char a)
cstr_insert_cstr	rsw_cstr.c	/^int cstr_insert_cstr(rsw_cstr* str, size_t i, rsw_cstr* a_str)$/;"	f	signature:(rsw_cstr* str, size_t i, rsw_cstr* a_str)
cstr_insert_cstr	rsw_cstr.h	/^int cstr_insert_cstr(rsw_cstr* str, size_t i, rsw_cstr* a_str);$/;"	p	signature:(rsw_cstr* str, size_t i, rsw_cstr* a_str)
cstr_insert_str	rsw_cstr.c	/^int cstr_insert_str(rsw_cstr* str, size_t i, char* a, size_t len)$/;"	f	signature:(rsw_cstr* str, size_t i, char* a, size_t len)
cstr_insert_str	rsw_cstr.h	/^int cstr_insert_str(rsw_cstr* str, size_t i, char* a, size_t len);$/;"	p	signature:(rsw_cstr* str, size_t i, char* a, size_t len)
cstr_ltrim	rsw_cstr.c	/^rsw_cstr* cstr_ltrim(rsw_cstr* str)$/;"	f	signature:(rsw_cstr* str)
cstr_ltrim	rsw_cstr.h	/^rsw_cstr* cstr_ltrim(rsw_cstr* str);$/;"	p	signature:(rsw_cstr* str)
cstr_pop	rsw_cstr.c	/^char cstr_pop(rsw_cstr* str)$/;"	f	signature:(rsw_cstr* str)
cstr_pop	rsw_cstr.h	/^char cstr_pop(rsw_cstr* str);$/;"	p	signature:(rsw_cstr* str)
cstr_push	rsw_cstr.c	/^int cstr_push(rsw_cstr* str, char a)$/;"	f	signature:(rsw_cstr* str, char a)
cstr_push	rsw_cstr.h	/^int cstr_push(rsw_cstr* str, char a);$/;"	p	signature:(rsw_cstr* str, char a)
cstr_replace	rsw_cstr.c	/^int cstr_replace(rsw_cstr* str, char* find, char* a, size_t count)$/;"	f	signature:(rsw_cstr* str, char* find, char* a, size_t count)
cstr_replace	rsw_cstr.h	/^int cstr_replace(rsw_cstr* str, char* find, char* a, size_t num);$/;"	p	signature:(rsw_cstr* str, char* find, char* a, size_t num)
cstr_replace_substr	rsw_cstr.c	/^int cstr_replace_substr(rsw_cstr* str, size_t index, size_t num, char* a, size_t len)$/;"	f	signature:(rsw_cstr* str, size_t index, size_t num, char* a, size_t len)
cstr_replace_substr	rsw_cstr.h	/^int cstr_replace_substr(rsw_cstr* str, size_t index, size_t num, char* a, size_t len);$/;"	p	signature:(rsw_cstr* str, size_t index, size_t num, char* a, size_t len)
cstr_replace_substr_cstr	rsw_cstr.c	/^int cstr_replace_substr_cstr(rsw_cstr* str, size_t index, size_t num, rsw_cstr* str2)$/;"	f	signature:(rsw_cstr* str, size_t index, size_t num, rsw_cstr* str2)
cstr_replace_substr_cstr	rsw_cstr.h	/^int cstr_replace_substr_cstr(rsw_cstr* str, size_t index, size_t num, rsw_cstr* str2);$/;"	p	signature:(rsw_cstr* str, size_t index, size_t num, rsw_cstr* str2)
cstr_reserve	rsw_cstr.c	/^int cstr_reserve(rsw_cstr* str, size_t size)$/;"	f	signature:(rsw_cstr* str, size_t size)
cstr_reserve	rsw_cstr.h	/^int cstr_reserve(rsw_cstr* str, size_t size);$/;"	p	signature:(rsw_cstr* str, size_t size)
cstr_resize	rsw_cstr.c	/^int cstr_resize(rsw_cstr* str, size_t size, int val)$/;"	f	signature:(rsw_cstr* str, size_t size, int val)
cstr_resize	rsw_cstr.h	/^int cstr_resize(rsw_cstr* str, size_t size, int val);$/;"	p	signature:(rsw_cstr* str, size_t size, int val)
cstr_rtrim	rsw_cstr.c	/^rsw_cstr* cstr_rtrim(rsw_cstr* str)$/;"	f	signature:(rsw_cstr* str)
cstr_rtrim	rsw_cstr.h	/^rsw_cstr* cstr_rtrim(rsw_cstr* str);$/;"	p	signature:(rsw_cstr* str)
cstr_set_capacity	rsw_cstr.c	/^int cstr_set_capacity(rsw_cstr* str, size_t size)$/;"	f	signature:(rsw_cstr* str, size_t size)
cstr_set_capacity	rsw_cstr.h	/^int cstr_set_capacity(rsw_cstr* str, size_t size); $/;"	p	signature:(rsw_cstr* str, size_t size)
cstr_set_str	rsw_cstr.c	/^int cstr_set_str(rsw_cstr* str, char* a, size_t len)$/;"	f	signature:(rsw_cstr* str, char* a, size_t len)
cstr_set_str	rsw_cstr.h	/^int cstr_set_str(rsw_cstr* str, char* a, size_t len);$/;"	p	signature:(rsw_cstr* str, char* a, size_t len)
cstr_set_val_cap	rsw_cstr.c	/^void cstr_set_val_cap(rsw_cstr* str, char val)$/;"	f	signature:(rsw_cstr* str, char val)
cstr_set_val_cap	rsw_cstr.h	/^void cstr_set_val_cap(rsw_cstr* str, char val);$/;"	p	signature:(rsw_cstr* str, char val)
cstr_set_val_sz	rsw_cstr.c	/^void cstr_set_val_sz(rsw_cstr* str, char val)$/;"	f	signature:(rsw_cstr* str, char val)
cstr_set_val_sz	rsw_cstr.h	/^void cstr_set_val_sz(rsw_cstr* str, char val);$/;"	p	signature:(rsw_cstr* str, char val)
cstr_split	rsw_cstr.c	/^int cstr_split(rsw_cstr* str, rsw_cstr* delim, rsw_cstr** results, size_t* num_results)$/;"	f	signature:(rsw_cstr* str, rsw_cstr* delim, rsw_cstr** results, size_t* num_results)
cstr_split	rsw_cstr.h	/^int cstr_split(rsw_cstr* str, rsw_cstr* delim, rsw_cstr** results, size_t* num_results);$/;"	p	signature:(rsw_cstr* str, rsw_cstr* delim, rsw_cstr** results, size_t* num_results)
cstr_substr	rsw_cstr.c	/^rsw_cstr cstr_substr(rsw_cstr* str, size_t index, size_t len)$/;"	f	signature:(rsw_cstr* str, size_t index, size_t len)
cstr_substr	rsw_cstr.h	/^rsw_cstr cstr_substr(rsw_cstr* str, size_t index, size_t len);$/;"	p	signature:(rsw_cstr* str, size_t index, size_t len)
cstr_trim	rsw_cstr.c	/^rsw_cstr* cstr_trim(rsw_cstr* str)$/;"	f	signature:(rsw_cstr* str)
cstr_trim	rsw_cstr.h	/^rsw_cstr* cstr_trim(rsw_cstr* str);$/;"	p	signature:(rsw_cstr* str)
cur_char	lexer.h	/^	unsigned int cur_char;$/;"	m	struct:lexer_state	access:public
cur_file	lexer.h	/^	char* cur_file;$/;"	m	struct:lexer_state	access:public
cur_iter	parser.h	/^	int cur_iter;$/;"	m	struct:program_state	access:public
cur_iter_switch	parser.h	/^	int cur_iter_switch;$/;"	m	struct:program_state	access:public
cur_line	lexer.h	/^	unsigned int cur_line;$/;"	m	struct:lexer_state	access:public
cur_parent	parser.h	/^	int cur_parent; \/\/<-- location of open block statement$/;"	m	struct:program_state	access:public
cur_parent	parser.h	/^	int cur_parent;$/;"	m	struct:symbol	access:public
cur_pos	lexer.h	/^	unsigned int cur_pos;$/;"	m	struct:lexer_state	access:public
cur_tok	lexer.h	/^	unsigned int cur_tok;$/;"	m	struct:lexer_state	access:public
data	c_utils.h	/^	byte* data;$/;"	m	struct:c_array	access:public
data	clist.h	/^	int data;$/;"	m	struct:int_list	access:public
data	parser.h	/^	expression* data;$/;"	m	struct:expr_block	access:public
decl_stmt	parser.h	/^	int decl_stmt;$/;"	m	struct:binding	access:public
declaration	parser.c	/^void declaration(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
declaration	parser.h	/^void declaration(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
declaration_or_statement	parser.c	/^void declaration_or_statement(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
declaration_or_statement	parser.h	/^void declaration_or_statement(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
declaration_or_statement_list	parser.c	/^void declaration_or_statement_list(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
declaration_or_statement_list	parser.h	/^void declaration_or_statement_list(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
declaration_specifier	parser.c	/^var_type declaration_specifier(parsing_state* p, program_state* prog, int match, int* tokens)$/;"	f	signature:(parsing_state* p, program_state* prog, int match, int* tokens)
declaration_specifier	parser.h	/^var_type declaration_specifier(parsing_state* p, program_state* prog, int match, int* tokens);$/;"	p	signature:(parsing_state* p, program_state* prog, int match, int* tokens)
do_stmt	parser.c	/^void do_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
do_stmt	parser.h	/^void do_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
double_val	lexer.h	/^		double double_val;$/;"	m	union:token_value::__anon5	access:public
double_val	parser.h	/^		double double_val;$/;"	m	union:var_value::__anon2	access:public
elem_free	cvector.h	/^	void (*elem_free)(void*);$/;"	m	struct:vector_void	access:public
elem_free	vector_token_lex.h	/^	void (*elem_free)(void*);$/;"	m	struct:vector_token_lex	access:public
elem_init	cvector.h	/^	void (*elem_init)(void*, void*);$/;"	m	struct:vector_void	access:public
elem_init	vector_token_lex.h	/^	void (*elem_init)(void*, void*);$/;"	m	struct:vector_token_lex	access:public
elem_size	c_utils.h	/^	size_t elem_size;$/;"	m	struct:c_array	access:public
elem_size	cvector.h	/^	size_t elem_size;        \/**< Size in u8s of type stored (sizeof(T) where T is type). *\/$/;"	m	struct:vector_void	access:public
equality_expr	parser.c	/^void equality_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
equality_expr	parser.h	/^void equality_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
erase_d	cvector.h	/^void erase_d(vector_d* vec, size_t start, size_t end)$/;"	f	signature:(vector_d* vec, size_t start, size_t end)
erase_d	cvector.h	/^void erase_d(vector_d* vec, size_t start, size_t end);$/;"	p	signature:(vector_d* vec, size_t start, size_t end)
erase_i	cvector.h	/^void erase_i(vector_i* vec, size_t start, size_t end)$/;"	f	signature:(vector_i* vec, size_t start, size_t end)
erase_i	cvector.h	/^void erase_i(vector_i* vec, size_t start, size_t end);$/;"	p	signature:(vector_i* vec, size_t start, size_t end)
erase_str	cvector.h	/^void erase_str(vector_str* vec, size_t start, size_t end)$/;"	f	signature:(vector_str* vec, size_t start, size_t end)
erase_str	cvector.h	/^void erase_str(vector_str* vec, size_t start, size_t end);$/;"	p	signature:(vector_str* vec, size_t start, size_t end)
erase_token_lex	vector_token_lex.h	/^void erase_token_lex(vector_token_lex* vec, size_t start, size_t end)$/;"	f	signature:(vector_token_lex* vec, size_t start, size_t end)
erase_token_lex	vector_token_lex.h	/^void erase_token_lex(vector_token_lex* vec, size_t start, size_t end);$/;"	p	signature:(vector_token_lex* vec, size_t start, size_t end)
erase_void	cvector.h	/^void erase_void(vector_void* vec, size_t start, size_t end)$/;"	f	signature:(vector_void* vec, size_t start, size_t end)
erase_void	cvector.h	/^void erase_void(vector_void* vec, size_t start, size_t end);$/;"	p	signature:(vector_void* vec, size_t start, size_t end)
execute	interpreter.c	/^void execute(program_state* prog)$/;"	f	signature:(program_state* prog)
execute	interpreter.h	/^void execute(program_state* prog);$/;"	p	signature:(program_state* prog)
execute_constant_expr	interpreter.c	/^var_value execute_constant_expr(program_state* prog, expression* e)$/;"	f	signature:(program_state* prog, expression* e)
execute_constant_expr	interpreter.h	/^var_value execute_constant_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
execute_constant_expr	parser.h	/^var_value execute_constant_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
execute_expr	interpreter.c	/^var_value execute_expr(program_state* prog, expression* e)$/;"	f	signature:(program_state* prog, expression* e)
execute_expr	interpreter.h	/^var_value execute_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
execute_expr	parser.h	/^var_value execute_expr(program_state* prog, expression* e);$/;"	p	signature:(program_state* prog, expression* e)
execute_expr_list	interpreter.c	/^void execute_expr_list(program_state* prog, function* callee, expression* e)$/;"	f	signature:(program_state* prog, function* callee, expression* e)
execute_expr_list	interpreter.h	/^void execute_expr_list(program_state* prog, function* callee, expression* e);$/;"	p	signature:(program_state* prog, function* callee, expression* e)
execute_goto	interpreter.c	/^void execute_goto(program_state* prog, statement* stmt)$/;"	f	signature:(program_state* prog, statement* stmt)
execute_goto	interpreter.h	/^void execute_goto(program_state* prog, statement* stmt);$/;"	p	signature:(program_state* prog, statement* stmt)
execute_print	interpreter.c	/^void execute_print(var_value a)$/;"	f	signature:(var_value a)
execute_print	interpreter.h	/^void execute_print(var_value a);$/;"	p	signature:(var_value a)
exp	parser.h	/^	expression* exp;$/;"	m	struct:statement	access:public
expr	parser.c	/^void expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
expr	parser.h	/^void expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
expr_block	parser.h	/^typedef struct expr_block$/;"	s
expr_block	parser.h	/^} expr_block;$/;"	t	typeref:struct:expr_block
expr_block::data	parser.h	/^	expression* data;$/;"	m	struct:expr_block	access:public
expr_block::n	parser.h	/^	size_t n;$/;"	m	struct:expr_block	access:public
expr_block::used	parser.h	/^	size_t used;$/;"	m	struct:expr_block	access:public
expression	parser.h	/^struct expression$/;"	s
expression	parser.h	/^typedef struct expression expression;$/;"	t	typeref:struct:expression
expression::left	parser.h	/^	expression* left;$/;"	m	struct:expression	access:public
expression::right	parser.h	/^	expression* right;$/;"	m	struct:expression	access:public
expression::tok	parser.h	/^	token_value tok;$/;"	m	struct:expression	access:public
expression_list	parser.c	/^void expression_list(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
expression_list	parser.h	/^void expression_list(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
expression_stmt	parser.c	/^void expression_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
expression_stmt	parser.h	/^void expression_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
expressions	parser.h	/^	vector_void expressions;$/;"	m	struct:program_state	access:public
extend_d	cvector.h	/^int extend_d(vector_d* vec, size_t num)$/;"	f	signature:(vector_d* vec, size_t num)
extend_d	cvector.h	/^int extend_d(vector_d* vec, size_t num);$/;"	p	signature:(vector_d* vec, size_t num)
extend_i	cvector.h	/^int extend_i(vector_i* vec, size_t num)$/;"	f	signature:(vector_i* vec, size_t num)
extend_i	cvector.h	/^int extend_i(vector_i* vec, size_t num);$/;"	p	signature:(vector_i* vec, size_t num)
extend_str	cvector.h	/^int extend_str(vector_str* vec, size_t num)$/;"	f	signature:(vector_str* vec, size_t num)
extend_str	cvector.h	/^int extend_str(vector_str* vec, size_t num);$/;"	p	signature:(vector_str* vec, size_t num)
extend_token_lex	vector_token_lex.h	/^int extend_token_lex(vector_token_lex* vec, size_t num)$/;"	f	signature:(vector_token_lex* vec, size_t num)
extend_token_lex	vector_token_lex.h	/^int extend_token_lex(vector_token_lex* vec, size_t num);$/;"	p	signature:(vector_token_lex* vec, size_t num)
extend_void	cvector.h	/^int extend_void(vector_void* vec, size_t num)$/;"	f	signature:(vector_void* vec, size_t num)
extend_void	cvector.h	/^int extend_void(vector_void* vec, size_t num);$/;"	p	signature:(vector_void* vec, size_t num)
file_open_read	c_utils.c	/^int file_open_read(const char* filename, const char* mode, c_array* out)$/;"	f	signature:(const char* filename, const char* mode, c_array* out)
file_open_read	c_utils.h	/^int file_open_read(const char* filename, const char* mode, c_array* out);$/;"	p	signature:(const char* filename, const char* mode, c_array* out)
file_open_read_cstr	rsw_cstr.c	/^int file_open_read_cstr(const char* filename, rsw_cstr* str)$/;"	f	signature:(const char* filename, rsw_cstr* str)
file_open_read_cstr	rsw_cstr.h	/^int file_open_read_cstr(const char* filename, rsw_cstr* out);$/;"	p	signature:(const char* filename, rsw_cstr* out)
file_open_read_new_cstr	rsw_cstr.c	/^int file_open_read_new_cstr(const char* filename, rsw_cstr* str)$/;"	f	signature:(const char* filename, rsw_cstr* str)
file_open_read_new_cstr	rsw_cstr.h	/^int file_open_read_new_cstr(const char* filename, rsw_cstr* str);$/;"	p	signature:(const char* filename, rsw_cstr* str)
file_open_readlines	c_utils.c	/^int file_open_readlines(const char* filename, c_array* lines, c_array* file_contents)$/;"	f	signature:(const char* filename, c_array* lines, c_array* file_contents)
file_open_readlines	c_utils.h	/^int file_open_readlines(const char* filename, c_array* lines, c_array* file_contents);$/;"	p	signature:(const char* filename, c_array* lines, c_array* file_contents)
file_open_readlines_cstr	rsw_cstr.c	/^int file_open_readlines_cstr(const char* filename, rsw_cstr** lines, size_t* num_results)$/;"	f	signature:(const char* filename, rsw_cstr** lines, size_t* num_results)
file_open_readlines_cstr	rsw_cstr.h	/^int file_open_readlines_cstr(const char* filename, rsw_cstr** lines, size_t* num_results);$/;"	p	signature:(const char* filename, rsw_cstr** lines, size_t* num_results)
file_open_write	c_utils.c	/^int file_open_write(const char* filename, const char* mode, c_array* out)$/;"	f	signature:(const char* filename, const char* mode, c_array* out)
file_open_write	c_utils.h	/^int file_open_write(const char* filename, const char* mode, c_array* out);$/;"	p	signature:(const char* filename, const char* mode, c_array* out)
file_open_write_cstr	rsw_cstr.c	/^int file_open_write_cstr(const char* filename, rsw_cstr* str)$/;"	f	signature:(const char* filename, rsw_cstr* str)
file_open_write_cstr	rsw_cstr.h	/^int file_open_write_cstr(const char* filename, rsw_cstr* out);$/;"	p	signature:(const char* filename, rsw_cstr* out)
file_read	c_utils.c	/^int file_read(FILE* file, c_array* out)$/;"	f	signature:(FILE* file, c_array* out)
file_read	c_utils.h	/^int file_read(FILE* file, c_array* out);$/;"	p	signature:(FILE* file, c_array* out)
file_read_cstr	rsw_cstr.c	/^int file_read_cstr(FILE* file, rsw_cstr* str)$/;"	f	signature:(FILE* file, rsw_cstr* str)
file_read_cstr	rsw_cstr.h	/^int file_read_cstr(FILE* file, rsw_cstr* out);$/;"	p	signature:(FILE* file, rsw_cstr* out)
file_read_new_cstr	rsw_cstr.c	/^int file_read_new_cstr(FILE* file, rsw_cstr* str)$/;"	f	signature:(FILE* file, rsw_cstr* str)
file_read_new_cstr	rsw_cstr.h	/^int file_read_new_cstr(FILE* file, rsw_cstr* str);$/;"	p	signature:(FILE* file, rsw_cstr* str)
file_readlines	c_utils.c	/^int file_readlines(FILE* file, c_array* lines, c_array* file_contents)$/;"	f	signature:(FILE* file, c_array* lines, c_array* file_contents)
file_readlines	c_utils.h	/^int file_readlines(FILE* file, c_array* lines, c_array* file_contents);$/;"	p	signature:(FILE* file, c_array* lines, c_array* file_contents)
file_write	c_utils.c	/^int file_write(FILE* file, c_array* out)$/;"	f	signature:(FILE* file, c_array* out)
file_write	c_utils.h	/^int file_write(FILE* file, c_array* out);$/;"	p	signature:(FILE* file, c_array* out)
file_write_cstr	rsw_cstr.c	/^int file_write_cstr(FILE* file, rsw_cstr* str)$/;"	f	signature:(FILE* file, rsw_cstr* str)
file_write_cstr	rsw_cstr.h	/^int file_write_cstr(FILE* file, rsw_cstr* out);$/;"	p	signature:(FILE* file, rsw_cstr* out)
find	c_utils.c	/^size_t find(c_array haystack, c_array needle)$/;"	f	signature:(c_array haystack, c_array needle)
find	c_utils.h	/^size_t find(c_array haystack, c_array needle);$/;"	p	signature:(c_array haystack, c_array needle)
find_lowest_common_ancestor	interpreter.c	/^int find_lowest_common_ancestor(program_state* prog, int parent1, int parent2)$/;"	f	signature:(program_state* prog, int parent1, int parent2)
find_lowest_common_ancestor	interpreter.h	/^int find_lowest_common_ancestor(program_state* prog, int parent1, int parent2);$/;"	p	signature:(program_state* prog, int parent1, int parent2)
find_lowest_common_ancestor	parser.h	/^int find_lowest_common_ancestor(program_state* prog, int parent1, int parent2);$/;"	p	signature:(program_state* prog, int parent1, int parent2)
float_val	lexer.h	/^		float float_val;$/;"	m	union:token_value::__anon5	access:public
float_val	parser.h	/^		float float_val;$/;"	m	union:var_value::__anon2	access:public
for_stmt	parser.c	/^void for_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
for_stmt	parser.h	/^void for_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
fpeek	c_utils.c	/^int fpeek(FILE* input)$/;"	f	signature:(FILE* input)
fpeek	c_utils.h	/^int fpeek(FILE* input);$/;"	p	signature:(FILE* input)
freadline	c_utils.c	/^char* freadline(FILE* input)$/;"	f	signature:(FILE* input)
freadline	c_utils.h	/^char* freadline(FILE* input);$/;"	p	signature:(FILE* input)
freadline_into_cstr	rsw_cstr.c	/^int freadline_into_cstr(FILE* input, rsw_cstr* str)$/;"	f	signature:(FILE* input, rsw_cstr* str)
freadline_into_cstr	rsw_cstr.h	/^int freadline_into_cstr(FILE* input, rsw_cstr* str);$/;"	p	signature:(FILE* input, rsw_cstr* str)
freadline_into_new_cstr	rsw_cstr.c	/^int freadline_into_new_cstr(FILE* input, rsw_cstr* str)$/;"	f	signature:(FILE* input, rsw_cstr* str)
freadline_into_new_cstr	rsw_cstr.h	/^int freadline_into_new_cstr(FILE* input, rsw_cstr* str);$/;"	p	signature:(FILE* input, rsw_cstr* str)
freadline_into_str	c_utils.c	/^int freadline_into_str(FILE* input, char* str, size_t len)$/;"	f	signature:(FILE* input, char* str, size_t len)
freadline_into_str	c_utils.h	/^int freadline_into_str(FILE* input, char* str, size_t len);$/;"	p	signature:(FILE* input, char* str, size_t len)
freadstring	c_utils.c	/^char* freadstring(FILE* input, int delim, size_t max_len)$/;"	f	signature:(FILE* input, int delim, size_t max_len)
freadstring	c_utils.h	/^char* freadstring(FILE* input, int delim, size_t max_len);$/;"	p	signature:(FILE* input, int delim, size_t max_len)
freadstring_into_cstr	rsw_cstr.c	/^int freadstring_into_cstr(FILE* input, int delim, rsw_cstr* str)$/;"	f	signature:(FILE* input, int delim, rsw_cstr* str)
freadstring_into_cstr	rsw_cstr.h	/^int freadstring_into_cstr(FILE* input, int delim, rsw_cstr* str);$/;"	p	signature:(FILE* input, int delim, rsw_cstr* str)
freadstring_into_new_cstr	rsw_cstr.c	/^int freadstring_into_new_cstr(FILE* input, int delim, rsw_cstr* str)$/;"	f	signature:(FILE* input, int delim, rsw_cstr* str)
freadstring_into_new_cstr	rsw_cstr.h	/^int freadstring_into_new_cstr(FILE* input, int delim, rsw_cstr* str);$/;"	p	signature:(FILE* input, int delim, rsw_cstr* str)
freadstring_into_str	c_utils.c	/^int freadstring_into_str(FILE* input, int delim, char* str, size_t len)$/;"	f	signature:(FILE* input, int delim, char* str, size_t len)
freadstring_into_str	c_utils.h	/^int freadstring_into_str(FILE* input, int delim, char* str, size_t len);$/;"	p	signature:(FILE* input, int delim, char* str, size_t len)
free_active_binding_list	parser.c	/^void free_active_binding_list(void* l)$/;"	f	signature:(void* l)
free_active_binding_list	parser.h	/^void free_active_binding_list(void* l);$/;"	p	signature:(void* l)
free_cstr	rsw_cstr.c	/^void free_cstr(void* str)$/;"	f	signature:(void* str)
free_cstr	rsw_cstr.h	/^void free_cstr(void* str);$/;"	p	signature:(void* str)
free_cstr_heap	rsw_cstr.c	/^void free_cstr_heap(void* str)$/;"	f	signature:(void* str)
free_cstr_heap	rsw_cstr.h	/^void free_cstr_heap(void* str);$/;"	p	signature:(void* str)
free_expr_block	parser.c	/^void free_expr_block(void* block)$/;"	f	signature:(void* block)
free_function	parser.c	/^void free_function(void* func)$/;"	f	signature:(void* func)
free_macro_params	preprocessor.c	/^void free_macro_params(void* param)$/;"	f	signature:(void* param)
free_macro_params	preprocessor.h	/^void free_macro_params(void* param);$/;"	p	signature:(void* param)
free_statement	parser.c	/^void free_statement(void* stmt)$/;"	f	signature:(void* stmt)
free_statement	parser.h	/^void free_statement(void* stmt);$/;"	p	signature:(void* stmt)
free_symbol	parser.c	/^void free_symbol(void* var)$/;"	f	signature:(void* var)
free_token_lex	lexer.c	/^void free_token_lex(void* tok_lex)$/;"	f	signature:(void* tok_lex)
free_token_lex	lexer.h	/^void free_token_lex(void* tok_lex);$/;"	p	signature:(void* tok_lex)
free_var_value	parser.c	/^void free_var_value(void* var)$/;"	f	signature:(void* var)
free_var_value	parser.h	/^void free_var_value(void* var);$/;"	p	signature:(void* var)
free_vec_d	cvector.h	/^void free_vec_d(void* vec)$/;"	f	signature:(void* vec)
free_vec_d	cvector.h	/^void free_vec_d(void* vec);$/;"	p	signature:(void* vec)
free_vec_d_heap	cvector.h	/^void free_vec_d_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_d_heap	cvector.h	/^void free_vec_d_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_i	cvector.h	/^void free_vec_i(void* vec)$/;"	f	signature:(void* vec)
free_vec_i	cvector.h	/^void free_vec_i(void* vec);$/;"	p	signature:(void* vec)
free_vec_i_heap	cvector.h	/^void free_vec_i_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_i_heap	cvector.h	/^void free_vec_i_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_str	cvector.h	/^void free_vec_str(void* vec)$/;"	f	signature:(void* vec)
free_vec_str	cvector.h	/^void free_vec_str(void* vec);$/;"	p	signature:(void* vec)
free_vec_str_heap	cvector.h	/^void free_vec_str_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_str_heap	cvector.h	/^void free_vec_str_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_token_lex	vector_token_lex.h	/^void free_vec_token_lex(void* vec)$/;"	f	signature:(void* vec)
free_vec_token_lex	vector_token_lex.h	/^void free_vec_token_lex(void* vec);$/;"	p	signature:(void* vec)
free_vec_token_lex_heap	vector_token_lex.h	/^void free_vec_token_lex_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_token_lex_heap	vector_token_lex.h	/^void free_vec_token_lex_heap(void* vec);$/;"	p	signature:(void* vec)
free_vec_void	cvector.h	/^void free_vec_void(void* vec)$/;"	f	signature:(void* vec)
free_vec_void	cvector.h	/^void free_vec_void(void* vec);$/;"	p	signature:(void* vec)
free_vec_void_heap	cvector.h	/^void free_vec_void_heap(void* vec)$/;"	f	signature:(void* vec)
free_vec_void_heap	cvector.h	/^void free_vec_void_heap(void* vec);$/;"	p	signature:(void* vec)
func	parser.h	/^	function* func;$/;"	m	struct:program_state	access:public
func_loc	parser.h	/^		unsigned int func_loc; \/\/change to direct pointer?$/;"	m	union:var_value::__anon2	access:public
function	parser.h	/^typedef struct function$/;"	s
function	parser.h	/^} function;$/;"	t	typeref:struct:function
function::label_locs	parser.h	/^	vector_i label_locs;$/;"	m	struct:function	access:public
function::labels	parser.h	/^	vector_str labels;$/;"	m	struct:function	access:public
function::n_params	parser.h	/^	int n_params;$/;"	m	struct:function	access:public
function::pc	parser.h	/^	size_t pc;$/;"	m	struct:function	access:public
function::ret_val	parser.h	/^	var_value ret_val;$/;"	m	struct:function	access:public
function::stmt_list	parser.h	/^	vector_void stmt_list;$/;"	m	struct:function	access:public
function::symbols	parser.h	/^	vector_void symbols;$/;"	m	struct:function	access:public
function_call	parser.c	/^void function_call(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
function_call	parser.h	/^void function_call(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
function_declarator	parser.c	/^void function_declarator(parsing_state* p, program_state* prog, var_type vtype)$/;"	f	signature:(parsing_state* p, program_state* prog, var_type vtype)
function_declarator	parser.h	/^void function_declarator(parsing_state* p, program_state* prog, var_type vtype);$/;"	p	signature:(parsing_state* p, program_state* prog, var_type vtype)
function_definition	parser.c	/^void function_definition(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
function_definition	parser.h	/^void function_definition(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
functions	parser.h	/^	vector_void functions;$/;"	m	struct:program_state	access:public
get_token	parser.c	/^token_value* get_token(parsing_state* p)$/;"	f	signature:(parsing_state* p)
global_values	parser.h	/^	vector_void global_values;$/;"	m	struct:program_state	access:public
global_variables	parser.h	/^	vector_str global_variables;$/;"	m	struct:program_state	access:public
goto_stmt	parser.c	/^void goto_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
goto_stmt	parser.h	/^void goto_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
handle_define	preprocessor.c	/^void handle_define(preprocessor_state* preproc)$/;"	f	signature:(preprocessor_state* preproc)
handle_define	preprocessor.h	/^void handle_define(preprocessor_state* preproc);$/;"	p	signature:(preprocessor_state* preproc)
handle_ifdef	preprocessor.c	/^void handle_ifdef(preprocessor_state* preproc)$/;"	f	signature:(preprocessor_state* preproc)
handle_ifdef	preprocessor.h	/^void handle_ifdef(preprocessor_state* preproc);$/;"	p	signature:(preprocessor_state* preproc)
handle_include	preprocessor.c	/^void handle_include(preprocessor_state* preproc)$/;"	f	signature:(preprocessor_state* preproc)
handle_include	preprocessor.h	/^void handle_include(preprocessor_state* preproc);$/;"	p	signature:(preprocessor_state* preproc)
handle_macro	preprocessor.c	/^void handle_macro(preprocessor_state* preproc, int macro)$/;"	f	signature:(preprocessor_state* preproc, int macro)
handle_macro	preprocessor.h	/^void handle_macro(preprocessor_state* preproc, int macro);$/;"	p	signature:(preprocessor_state* preproc, int macro)
head	parser.h	/^	list_head head;$/;"	m	struct:symbol	access:public
id	lexer.h	/^		char* id;$/;"	m	union:token_value::__anon5	access:public
if_stack	preprocessor.h	/^	vector_token_lex if_stack;$/;"	m	struct:preprocessor_state	access:public
if_stmt	parser.c	/^void if_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
if_stmt	parser.h	/^void if_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
init_c_array	c_utils.c	/^c_array init_c_array(byte* data, size_t elem_size, size_t len)$/;"	f	signature:(byte* data, size_t elem_size, size_t len)
init_c_array	c_utils.h	/^c_array init_c_array(byte* data, size_t elem_size, size_t len);$/;"	p	signature:(byte* data, size_t elem_size, size_t len)
init_cstr	rsw_cstr.c	/^int init_cstr(rsw_cstr* str)$/;"	f	signature:(rsw_cstr* str)
init_cstr	rsw_cstr.h	/^int init_cstr(rsw_cstr* str);$/;"	p	signature:(rsw_cstr* str)
init_cstr_cap	rsw_cstr.c	/^int init_cstr_cap(rsw_cstr* str, size_t capacity)$/;"	f	signature:(rsw_cstr* str, size_t capacity)
init_cstr_cap	rsw_cstr.h	/^int init_cstr_cap(rsw_cstr* str, size_t capacity);$/;"	p	signature:(rsw_cstr* str, size_t capacity)
init_cstr_str	rsw_cstr.c	/^int init_cstr_str(rsw_cstr* str, char* start, size_t len)$/;"	f	signature:(rsw_cstr* str, char* start, size_t len)
init_cstr_str	rsw_cstr.h	/^int init_cstr_str(rsw_cstr* str, char* start, size_t len);$/;"	p	signature:(rsw_cstr* str, char* start, size_t len)
init_cstr_sz	rsw_cstr.c	/^int init_cstr_sz(rsw_cstr* str, size_t size, int val)$/;"	f	signature:(rsw_cstr* str, size_t size, int val)
init_cstr_sz	rsw_cstr.h	/^int init_cstr_sz(rsw_cstr* str, size_t size, int val);$/;"	p	signature:(rsw_cstr* str, size_t size, int val)
init_cstr_sz_cap	rsw_cstr.c	/^int init_cstr_sz_cap(rsw_cstr* str, size_t size, int val, size_t capacity)$/;"	f	signature:(rsw_cstr* str, size_t size, int val, size_t capacity)
init_cstr_sz_cap	rsw_cstr.h	/^int init_cstr_sz_cap(rsw_cstr* str, size_t size, int val, size_t capacity);$/;"	p	signature:(rsw_cstr* str, size_t size, int val, size_t capacity)
init_function	parser.c	/^void init_function(void* to, void* from)$/;"	f	signature:(void* to, void* from)
init_vec_d	cvector.h	/^int init_vec_d(vector_d* vec, double* vals, size_t num)$/;"	f	signature:(vector_d* vec, double* vals, size_t num)
init_vec_d	cvector.h	/^int init_vec_d(vector_d* vec, double* vals, size_t num);$/;"	p	signature:(vector_d* vec, double* vals, size_t num)
init_vec_d_heap	cvector.h	/^vector_d* init_vec_d_heap(double* vals, size_t num)$/;"	f	signature:(double* vals, size_t num)
init_vec_d_heap	cvector.h	/^vector_d* init_vec_d_heap(double* vals, size_t num);$/;"	p	signature:(double* vals, size_t num)
init_vec_i	cvector.h	/^int init_vec_i(vector_i* vec, int* vals, size_t num)$/;"	f	signature:(vector_i* vec, int* vals, size_t num)
init_vec_i	cvector.h	/^int init_vec_i(vector_i* vec, int* vals, size_t num);$/;"	p	signature:(vector_i* vec, int* vals, size_t num)
init_vec_i_heap	cvector.h	/^vector_i* init_vec_i_heap(int* vals, size_t num)$/;"	f	signature:(int* vals, size_t num)
init_vec_i_heap	cvector.h	/^vector_i* init_vec_i_heap(int* vals, size_t num);$/;"	p	signature:(int* vals, size_t num)
init_vec_str	cvector.h	/^int init_vec_str(vector_str* vec, char** vals, size_t num)$/;"	f	signature:(vector_str* vec, char** vals, size_t num)
init_vec_str	cvector.h	/^int init_vec_str(vector_str* vec, char** vals, size_t num);$/;"	p	signature:(vector_str* vec, char** vals, size_t num)
init_vec_str_heap	cvector.h	/^vector_str* init_vec_str_heap(char** vals, size_t num)$/;"	f	signature:(char** vals, size_t num)
init_vec_str_heap	cvector.h	/^vector_str* init_vec_str_heap(char** vals, size_t num);$/;"	p	signature:(char** vals, size_t num)
init_vec_token_lex	vector_token_lex.h	/^int init_vec_token_lex(vector_token_lex* vec, token_lex* vals, size_t num, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(vector_token_lex* vec, token_lex* vals, size_t num, void(*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_token_lex	vector_token_lex.h	/^int init_vec_token_lex(vector_token_lex* vec, token_lex* vals, size_t num, void(*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(vector_token_lex* vec, token_lex* vals, size_t num, void(*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_token_lex_heap	vector_token_lex.h	/^vector_token_lex* init_vec_token_lex_heap(token_lex* vals, size_t num, void (*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(token_lex* vals, size_t num, void (*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_token_lex_heap	vector_token_lex.h	/^vector_token_lex* init_vec_token_lex_heap(token_lex* vals, size_t num, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(token_lex* vals, size_t num, void(*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_void	cvector.h	/^int init_vec_void(vector_void* vec, void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(vector_void* vec, void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_void	cvector.h	/^int init_vec_void(vector_void* vec, void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(vector_void* vec, void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_void_heap	cvector.h	/^vector_void* init_vec_void_heap(void* vals, size_t num, size_t elem_sz, void (*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(void* vals, size_t num, size_t elem_sz, void (*elem_free)(void*), void(*elem_init)(void*, void*))
init_vec_void_heap	cvector.h	/^vector_void* init_vec_void_heap(void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(void* vals, size_t num, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
initialized_declarator	parser.c	/^void initialized_declarator(parsing_state* p, program_state* prog, var_type v_type)$/;"	f	signature:(parsing_state* p, program_state* prog, var_type v_type)
initialized_declarator	parser.h	/^void initialized_declarator(parsing_state* p, program_state* prog, var_type v_type);$/;"	p	signature:(parsing_state* p, program_state* prog, var_type v_type)
initialized_declarator_list	parser.c	/^void initialized_declarator_list(parsing_state* p, program_state* prog, var_type v_type)$/;"	f	signature:(parsing_state* p, program_state* prog, var_type v_type)
initialized_declarator_list	parser.h	/^void initialized_declarator_list(parsing_state* p, program_state* prog, var_type v_type);$/;"	p	signature:(parsing_state* p, program_state* prog, var_type v_type)
input	preprocessor.h	/^	FILE* input;$/;"	m	struct:preprocessor_state	access:public
insert_array_d	cvector.h	/^int insert_array_d(vector_d* vec, size_t i, double* a, size_t num)$/;"	f	signature:(vector_d* vec, size_t i, double* a, size_t num)
insert_array_d	cvector.h	/^int insert_array_d(vector_d* vec, size_t i, double* a, size_t num);$/;"	p	signature:(vector_d* vec, size_t i, double* a, size_t num)
insert_array_i	cvector.h	/^int insert_array_i(vector_i* vec, size_t i, int* a, size_t num)$/;"	f	signature:(vector_i* vec, size_t i, int* a, size_t num)
insert_array_i	cvector.h	/^int insert_array_i(vector_i* vec, size_t i, int* a, size_t num);$/;"	p	signature:(vector_i* vec, size_t i, int* a, size_t num)
insert_array_str	cvector.h	/^int insert_array_str(vector_str* vec, size_t i, char** , size_t num);$/;"	p	signature:(vector_str* vec, size_t i, char** , size_t num)
insert_array_str	cvector.h	/^int insert_array_str(vector_str* vec, size_t i, char** a, size_t num)$/;"	f	signature:(vector_str* vec, size_t i, char** a, size_t num)
insert_array_token_lex	vector_token_lex.h	/^int insert_array_token_lex(vector_token_lex* vec, size_t i, token_lex* a, size_t num)$/;"	f	signature:(vector_token_lex* vec, size_t i, token_lex* a, size_t num)
insert_array_token_lex	vector_token_lex.h	/^int insert_array_token_lex(vector_token_lex* vec, size_t i, token_lex* a, size_t num);$/;"	p	signature:(vector_token_lex* vec, size_t i, token_lex* a, size_t num)
insert_array_void	cvector.h	/^int insert_array_void(vector_void* vec, size_t i, void* a, size_t num)$/;"	f	signature:(vector_void* vec, size_t i, void* a, size_t num)
insert_array_void	cvector.h	/^int insert_array_void(vector_void* vec, size_t i, void* a, size_t num);$/;"	p	signature:(vector_void* vec, size_t i, void* a, size_t num)
insert_d	cvector.h	/^int insert_d(vector_d* vec, size_t i, double a)$/;"	f	signature:(vector_d* vec, size_t i, double a)
insert_d	cvector.h	/^int insert_d(vector_d* vec, size_t i, double a);$/;"	p	signature:(vector_d* vec, size_t i, double a)
insert_i	cvector.h	/^int insert_i(vector_i* vec, size_t i, int a)$/;"	f	signature:(vector_i* vec, size_t i, int a)
insert_i	cvector.h	/^int insert_i(vector_i* vec, size_t i, int a);$/;"	p	signature:(vector_i* vec, size_t i, int a)
insert_str	cvector.h	/^int insert_str(vector_str* vec, size_t i, char* a)$/;"	f	signature:(vector_str* vec, size_t i, char* a)
insert_str	cvector.h	/^int insert_str(vector_str* vec, size_t i, char* a);$/;"	p	signature:(vector_str* vec, size_t i, char* a)
insert_token_lex	vector_token_lex.h	/^int insert_token_lex(vector_token_lex* vec, size_t i, token_lex* a)$/;"	f	signature:(vector_token_lex* vec, size_t i, token_lex* a)
insert_token_lex	vector_token_lex.h	/^int insert_token_lex(vector_token_lex* vec, size_t i, token_lex* a);$/;"	p	signature:(vector_token_lex* vec, size_t i, token_lex* a)
insert_void	cvector.h	/^int insert_void(vector_void* vec, size_t i, void* a)$/;"	f	signature:(vector_void* vec, size_t i, void* a)
insert_void	cvector.h	/^int insert_void(vector_void* vec, size_t i, void* a);$/;"	p	signature:(vector_void* vec, size_t i, void* a)
int_list	clist.h	/^typedef struct int_list$/;"	s
int_list	clist.h	/^} int_list;$/;"	t	typeref:struct:int_list
int_list::data	clist.h	/^	int data;$/;"	m	struct:int_list	access:public
int_list::list	clist.h	/^	list_head list;$/;"	m	struct:int_list	access:public
int_to_str	c_utils.c	/^char* int_to_str(int num, int base)$/;"	f	signature:(int num, int base)
int_to_str	c_utils.h	/^char* int_to_str(int num, int base);$/;"	p	signature:(int num, int base)
int_val	lexer.h	/^		int int_val;$/;"	m	union:token_value::__anon5	access:public
int_val	parser.h	/^		int int_val;$/;"	m	union:var_value::__anon2	access:public
is_ancestor	interpreter.c	/^int is_ancestor(program_state* prog, int parent, int child)$/;"	f	signature:(program_state* prog, int parent, int child)
is_ancestor	interpreter.h	/^int is_ancestor(program_state* prog, int parent, int child);$/;"	p	signature:(program_state* prog, int parent, int child)
is_ancestor	parser.h	/^int is_ancestor(program_state* prog, int parent, int child);$/;"	p	signature:(program_state* prog, int parent, int child)
is_any	c_utils.c	/^int is_any(c_array* array, const void* the_one, int (*are_equal)(const void*, const void*))$/;"	f	signature:(c_array* array, const void* the_one, int (*are_equal)(const void*, const void*))
is_any	c_utils.h	/^int is_any(c_array* array, const void* the_one, int (*are_equal)(const void*, const void*));$/;"	p	signature:(c_array* array, const void* the_one, int (*are_equal)(const void*, const void*))
is_integral_type	parser.c	/^int is_integral_type(var_value* v)$/;"	f	signature:(var_value* v)
is_true	interpreter.c	/^int is_true(var_value v)$/;"	f	signature:(var_value v)
is_true	interpreter.h	/^int is_true(var_value v);$/;"	p	signature:(var_value v)
jump_to	parser.h	/^	size_t jump_to;$/;"	m	struct:statement	access:public
jump_to	parser.h	/^	unsigned int jump_to;$/;"	m	struct:a_case	access:public
label_locs	parser.h	/^	vector_i label_locs;$/;"	m	struct:function	access:public
labeled_stmt	parser.c	/^void labeled_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
labeled_stmt	parser.h	/^void labeled_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
labels	parser.h	/^	vector_str labels;$/;"	m	struct:function	access:public
left	parser.h	/^	expression* left;$/;"	m	struct:expression	access:public
len	c_utils.h	/^	size_t len;$/;"	m	struct:c_array	access:public
lex_error	lexer.c	/^void lex_error(lexer_state* lex, char *str, ...)$/;"	f	signature:(lexer_state* lex, char *str, ...)
lex_error	lexer.h	/^void lex_error(lexer_state* lex, char *str, ...);$/;"	p	signature:(lexer_state* lex, char *str, ...)
lexer	preprocessor.h	/^	lexer_state lexer;$/;"	m	struct:preprocessor_state	access:public
lexer_state	lexer.h	/^typedef struct lexer_state$/;"	s
lexer_state	lexer.h	/^} lexer_state;$/;"	t	typeref:struct:lexer_state
lexer_state::cur_char	lexer.h	/^	unsigned int cur_char;$/;"	m	struct:lexer_state	access:public
lexer_state::cur_file	lexer.h	/^	char* cur_file;$/;"	m	struct:lexer_state	access:public
lexer_state::cur_line	lexer.h	/^	unsigned int cur_line;$/;"	m	struct:lexer_state	access:public
lexer_state::cur_pos	lexer.h	/^	unsigned int cur_pos;$/;"	m	struct:lexer_state	access:public
lexer_state::cur_tok	lexer.h	/^	unsigned int cur_tok;$/;"	m	struct:lexer_state	access:public
line	lexer.h	/^	unsigned int line;$/;"	m	struct:token_lex	access:public
list	clist.h	/^	list_head list;$/;"	m	struct:int_list	access:public
list	parser.h	/^	list_head list;$/;"	m	struct:active_binding	access:public
list_add	clist.h	/^static inline void list_add(list_head* item, list_head* head)$/;"	f	signature:(list_head* item, list_head* head)
list_add_tail	clist.h	/^static inline void list_add_tail(list_head* item, list_head* head)$/;"	f	signature:(list_head* item, list_head* head)
list_del	clist.h	/^static inline void list_del(list_head* item)$/;"	f	signature:(list_head* item)
list_empty	clist.h	/^static inline int list_empty(const list_head *head)$/;"	f	signature:(const list_head *head)
list_entry	clist.h	89;"	d
list_first_entry	clist.h	100;"	d
list_first_entry_or_null	clist.h	111;"	d
list_for_each	clist.h	119;"	d
list_for_each_entry	clist.h	169;"	d
list_for_each_entry_continue	clist.h	197;"	d
list_for_each_entry_continue_reverse	clist.h	212;"	d
list_for_each_entry_from	clist.h	226;"	d
list_for_each_entry_reverse	clist.h	181;"	d
list_for_each_entry_safe	clist.h	238;"	d
list_for_each_entry_safe_continue	clist.h	255;"	d
list_for_each_entry_safe_from	clist.h	272;"	d
list_for_each_entry_safe_reverse	clist.h	288;"	d
list_for_each_prev	clist.h	138;"	d
list_for_each_prev_safe	clist.h	157;"	d
list_for_each_safe	clist.h	147;"	d
list_head	clist.h	/^typedef struct list_head$/;"	s
list_head	clist.h	/^} list_head;$/;"	t	typeref:struct:list_head
list_head::next	clist.h	/^	struct list_head* next;$/;"	m	struct:list_head	typeref:struct:list_head::list_head	access:public
list_head::prev	clist.h	/^	struct list_head* prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head	access:public
list_is_last	clist.h	/^static inline int list_is_last(const list_head *list, const list_head *head)$/;"	f	signature:(const list_head *list, const list_head *head)
list_is_singular	clist.h	/^static inline int list_is_singular(const list_head *head)$/;"	f	signature:(const list_head *head)
list_replace	clist.h	/^static inline void list_replace(list_head* old, list_head* item)$/;"	f	signature:(list_head* old, list_head* item)
list_swap	clist.h	/^void list_swap(list_head* p, list_head* q)$/;"	f	signature:(list_head* p, list_head* q)
list_swap	clist.h	/^void list_swap(list_head* p, list_head* q);$/;"	p	signature:(list_head* p, list_head* q)
logical_and_expr	parser.c	/^void logical_and_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
logical_and_expr	parser.h	/^void logical_and_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
logical_negation_expr	parser.c	/^void logical_negation_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
logical_negation_expr	parser.h	/^void logical_negation_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
logical_or_expr	parser.c	/^void logical_or_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
logical_or_expr	parser.h	/^void logical_or_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
long_to_str	c_utils.h	/^char* long_to_str(long num, int base);$/;"	p	signature:(long num, int base)
long_val	parser.h	/^		long long_val;$/;"	m	union:var_value::__anon2	access:public
look_up_loc	interpreter.c	/^unsigned int look_up_loc(program_state* prog, const char* var)$/;"	f	signature:(program_state* prog, const char* var)
look_up_loc	interpreter.h	/^unsigned int look_up_loc(program_state* prog, const char* var);$/;"	p	signature:(program_state* prog, const char* var)
look_up_loc	parser.h	/^unsigned int look_up_loc(program_state* prog, const char* var);$/;"	p	signature:(program_state* prog, const char* var)
look_up_macro	preprocessor.c	/^char* look_up_macro(preprocessor_state* proc, char* macro)$/;"	f	signature:(preprocessor_state* proc, char* macro)
look_up_macro	preprocessor.h	/^char* look_up_macro(preprocessor_state* proc, char* macro);$/;"	p	signature:(preprocessor_state* proc, char* macro)
look_up_macro_loc	preprocessor.c	/^int look_up_macro_loc(preprocessor_state* proc, char* macro)$/;"	f	signature:(preprocessor_state* proc, char* macro)
look_up_macro_loc	preprocessor.h	/^int look_up_macro_loc(preprocessor_state* proc, char* macro);$/;"	p	signature:(preprocessor_state* proc, char* macro)
look_up_symbol	interpreter.c	/^symbol* look_up_symbol(program_state* prog, const char* var)$/;"	f	signature:(program_state* prog, const char* var)
look_up_symbol	interpreter.h	/^symbol* look_up_symbol(program_state* prog, const char* var);$/;"	p	signature:(program_state* prog, const char* var)
look_up_symbol	parser.h	/^symbol* look_up_symbol(program_state* prog, const char* var);$/;"	p	signature:(program_state* prog, const char* var)
look_up_value	interpreter.c	/^var_value* look_up_value(program_state* prog, const char* var, int search)$/;"	f	signature:(program_state* prog, const char* var, int search)
look_up_value	interpreter.h	/^var_value* look_up_value(program_state* prog, const char* var, int search);$/;"	p	signature:(program_state* prog, const char* var, int search)
look_up_value	parser.h	/^var_value* look_up_value(program_state* prog, const char* var, int search);$/;"	p	signature:(program_state* prog, const char* var, int search)
ltrim	c_utils.c	/^char* ltrim(char* str)$/;"	f	signature:(char* str)
ltrim	c_utils.h	/^char* ltrim(char* str);$/;"	p	signature:(char* str)
lvalue	parser.h	/^	char* lvalue;$/;"	m	struct:statement	access:public
macro_buf	preprocessor.c	/^static char macro_buf[MAX_MACRO_LEN];$/;"	v	file:
macro_expansion	preprocessor.c	/^unsigned int macro_expansion(preprocessor_state* preproc, rsw_cstr* expansion, unsigned long beginning, vector_i* valid_macros, int macro_index)$/;"	f	signature:(preprocessor_state* preproc, rsw_cstr* expansion, unsigned long beginning, vector_i* valid_macros, int macro_index)
macro_expansion	preprocessor.h	/^unsigned int macro_expansion(preprocessor_state* preproc, rsw_cstr* expansion, unsigned long beginning, vector_i* valid_macros, int macro_index);$/;"	p	signature:(preprocessor_state* preproc, rsw_cstr* expansion, unsigned long beginning, vector_i* valid_macros, int macro_index)
macro_params	preprocessor.h	/^typedef struct macro_params$/;"	s
macro_params	preprocessor.h	/^} macro_params;$/;"	t	typeref:struct:macro_params
macro_params::names	preprocessor.h	/^	char** names;$/;"	m	struct:macro_params	access:public
macro_params::num_params	preprocessor.h	/^	int num_params;$/;"	m	struct:macro_params	access:public
macros	preprocessor.h	/^	vector_str macros;$/;"	m	struct:preprocessor_state	access:public
main	main.c	/^int main(int argc, char** argv)$/;"	f	signature:(int argc, char** argv)
make_expression	parser.c	/^expression* make_expression(program_state* prog)$/;"	f	signature:(program_state* prog)
make_expression	parser.h	/^expression* make_expression(program_state* prog);$/;"	p	signature:(program_state* prog)
make_expression_block	parser.c	/^int make_expression_block(size_t n, expr_block* block)$/;"	f	signature:(size_t n, expr_block* block)
make_expression_block	parser.h	/^int make_expression_block(size_t n, expr_block* block);$/;"	p	signature:(size_t n, expr_block* block)
map	c_utils.c	/^void map(c_array* array, void (*func)(const void*))$/;"	f	signature:(c_array* array, void (*func)(const void*))
map	c_utils.h	/^void map(c_array* array, void (*func)(const void*));$/;"	p	signature:(c_array* array, void (*func)(const void*))
mult_expr	parser.c	/^void mult_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
mult_expr	parser.h	/^void mult_expr(parsing_state* p, program_state* prog, expression* exp);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* exp)
mybsearch	c_utils.c	/^void* mybsearch(const void *key, const void *buf, size_t num, size_t size, int (*compare)(const void *, const void *))$/;"	f	signature:(const void *key, const void *buf, size_t num, size_t size, int (*compare)(const void *, const void *))
mystrdup	c_utils.c	/^char* mystrdup(const char* str)$/;"	f	signature:(const char* str)
mystrdup	c_utils.h	/^char* mystrdup(const char* str);$/;"	p	signature:(const char* str)
n	parser.h	/^	size_t n;$/;"	m	struct:expr_block	access:public
n_params	parser.h	/^	int n_params;$/;"	m	struct:function	access:public
name	parser.h	/^	char* name;$/;"	m	struct:binding	access:public
name	parser.h	/^	char* name;$/;"	m	struct:symbol	access:public
names	preprocessor.h	/^	char** names;$/;"	m	struct:macro_params	access:public
next	clist.h	/^	struct list_head* next;$/;"	m	struct:list_head	typeref:struct:list_head::list_head	access:public
num_params	preprocessor.h	/^	int num_params;$/;"	m	struct:macro_params	access:public
offsetof	clist.h	78;"	d
output	preprocessor.h	/^	FILE* output;$/;"	m	struct:preprocessor_state	access:public
parameter_declaration	parser.c	/^void parameter_declaration(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
parameter_declaration	parser.h	/^void parameter_declaration(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
parameter_list	parser.c	/^void parameter_list(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
parameter_list	parser.h	/^void parameter_list(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
params	preprocessor.h	/^	vector_void params;$/;"	m	struct:preprocessor_state	access:public
parent	parser.h	/^	int parent;$/;"	m	struct:active_binding	access:public
parent	parser.h	/^	long parent;$/;"	m	struct:statement	access:public
parse_error	parser.c	/^void parse_error(token_value* tok, char *str, ...)$/;"	f	signature:(token_value* tok, char *str, ...)
parse_error	parser.h	/^void parse_error(token_value* tok, char *str, ...);$/;"	p	signature:(token_value* tok, char *str, ...)
parse_params	preprocessor.c	/^void parse_params(preprocessor_state* preproc, int macro, rsw_cstr* expansion)$/;"	f	signature:(preprocessor_state* preproc, int macro, rsw_cstr* expansion)
parse_params	preprocessor.h	/^void parse_params(preprocessor_state* preproc, int macro, rsw_cstr* expansion);$/;"	p	signature:(preprocessor_state* preproc, int macro, rsw_cstr* expansion)
parse_program_file	parser.c	/^void parse_program_file(program_state* prog, FILE* file)$/;"	f	signature:(program_state* prog, FILE* file)
parse_program_file	parser.h	/^void parse_program_file(program_state* prog, FILE* file);$/;"	p	signature:(program_state* prog, FILE* file)
parse_program_string	parser.c	/^void parse_program_string(program_state* prog, char* string)$/;"	f	signature:(program_state* prog, char* string)
parse_program_string	parser.h	/^void parse_program_string(program_state* prog, char* string);$/;"	p	signature:(program_state* prog, char* string)
parse_seek	parser.c	/^void parse_seek(parsing_state* p, int origin, long offset)$/;"	f	signature:(parsing_state* p, int origin, long offset)
parse_seek	parser.h	/^void parse_seek(parsing_state* p, int origin, long offset);$/;"	p	signature:(parsing_state* p, int origin, long offset)
parsing_state	parser.h	/^typedef struct parsing_state$/;"	s
parsing_state	parser.h	/^} parsing_state;$/;"	t	typeref:struct:parsing_state
parsing_state::pos	parser.h	/^	unsigned int pos;$/;"	m	struct:parsing_state	access:public
parsing_state::tokens	parser.h	/^	vector_token_lex tokens;$/;"	m	struct:parsing_state	access:public
pc	parser.h	/^	size_t pc;$/;"	m	struct:function	access:public
pc	parser.h	/^	size_t* pc;$/;"	m	struct:program_state	access:public
peek_token	parser.c	/^token_value* peek_token(parsing_state* p, long offset)$/;"	f	signature:(parsing_state* p, long offset)
peek_token	parser.h	/^token_value* peek_token(parsing_state* p, long offset);$/;"	p	signature:(parsing_state* p, long offset)
pop_d	cvector.h	/^double pop_d(vector_d* vec)$/;"	f	signature:(vector_d* vec)
pop_d	cvector.h	/^double pop_d(vector_d* vec);$/;"	p	signature:(vector_d* vec)
pop_i	cvector.h	/^int pop_i(vector_i* vec)$/;"	f	signature:(vector_i* vec)
pop_i	cvector.h	/^int pop_i(vector_i* vec);$/;"	p	signature:(vector_i* vec)
pop_scope	interpreter.c	/^void pop_scope(program_state* prog)$/;"	f	signature:(program_state* prog)
pop_scope	interpreter.h	/^void pop_scope(program_state* prog);$/;"	p	signature:(program_state* prog)
pop_scope	parser.h	/^void pop_scope(program_state* prog);$/;"	p	signature:(program_state* prog)
pop_str	cvector.h	/^void pop_str(vector_str* vec, char* ret)$/;"	f	signature:(vector_str* vec, char* ret)
pop_str	cvector.h	/^void pop_str(vector_str* vec, char* ret);$/;"	p	signature:(vector_str* vec, char* ret)
pop_token_lex	vector_token_lex.h	/^void pop_token_lex(vector_token_lex* vec, token_lex* ret)$/;"	f	signature:(vector_token_lex* vec, token_lex* ret)
pop_token_lex	vector_token_lex.h	/^void pop_token_lex(vector_token_lex* vec, token_lex* ret);$/;"	p	signature:(vector_token_lex* vec, token_lex* ret)
pop_void	cvector.h	/^void pop_void(vector_void* vec, void* ret)$/;"	f	signature:(vector_void* vec, void* ret)
pop_void	cvector.h	/^void pop_void(vector_void* vec, void* ret);$/;"	p	signature:(vector_void* vec, void* ret)
pos	lexer.h	/^	unsigned int pos; \/\/pos on line$/;"	m	struct:token_lex	access:public
pos	parser.h	/^	unsigned int pos;$/;"	m	struct:parsing_state	access:public
postfix_expr	parser.c	/^void postfix_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
postfix_expr	parser.h	/^void postfix_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
pre_inc_decrement_expr	parser.c	/^void pre_inc_decrement_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
pre_inc_decrement_expr	parser.h	/^void pre_inc_decrement_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
preprocess_file	preprocessor.c	/^void preprocess_file(preprocessor_state* preproc)$/;"	f	signature:(preprocessor_state* preproc)
preprocess_file	preprocessor.h	/^void preprocess_file(preprocessor_state* preproc);$/;"	p	signature:(preprocessor_state* preproc)
preprocessor_error	preprocessor.c	/^void preprocessor_error(token_lex* tok, lexer_state* lexer, char* str, ...)$/;"	f	signature:(token_lex* tok, lexer_state* lexer, char* str, ...)
preprocessor_error	preprocessor.h	/^void preprocessor_error(token_lex* tok, lexer_state* lexer, char* str, ...);$/;"	p	signature:(token_lex* tok, lexer_state* lexer, char* str, ...)
preprocessor_state	preprocessor.h	/^typedef struct preprocessor_state$/;"	s
preprocessor_state	preprocessor.h	/^} preprocessor_state;$/;"	t	typeref:struct:preprocessor_state
preprocessor_state::if_stack	preprocessor.h	/^	vector_token_lex if_stack;$/;"	m	struct:preprocessor_state	access:public
preprocessor_state::input	preprocessor.h	/^	FILE* input;$/;"	m	struct:preprocessor_state	access:public
preprocessor_state::lexer	preprocessor.h	/^	lexer_state lexer;$/;"	m	struct:preprocessor_state	access:public
preprocessor_state::macros	preprocessor.h	/^	vector_str macros;$/;"	m	struct:preprocessor_state	access:public
preprocessor_state::output	preprocessor.h	/^	FILE* output;$/;"	m	struct:preprocessor_state	access:public
preprocessor_state::params	preprocessor.h	/^	vector_void params;$/;"	m	struct:preprocessor_state	access:public
preprocessor_state::values	preprocessor.h	/^	vector_str values;$/;"	m	struct:preprocessor_state	access:public
prescan_argument	preprocessor.c	/^void prescan_argument(preprocessor_state* preproc, rsw_cstr* expansion)$/;"	f	signature:(preprocessor_state* preproc, rsw_cstr* expansion)
prescan_argument	preprocessor.h	/^void prescan_argument(preprocessor_state* preproc, rsw_cstr* expansion);$/;"	p	signature:(preprocessor_state* preproc, rsw_cstr* expansion)
prev	clist.h	/^	struct list_head* prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head	access:public
primary_expr	parser.c	/^void primary_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
primary_expr	parser.h	/^void primary_expr(parsing_state* p, program_state* prog, expression* exp);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* exp)
print_statement	parser.c	/^void print_statement(statement* stmt)$/;"	f	signature:(statement* stmt)
print_statement	parser.h	/^void print_statement(statement* stmt);$/;"	p	signature:(statement* stmt)
print_stmt	parser.c	/^void print_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
print_stmt	parser.h	/^void print_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
print_token	lexer.c	/^void print_token(token_value* tok, FILE* file, int print_enum)$/;"	f	signature:(token_value* tok, FILE* file, int print_enum)
print_token	lexer.h	/^void print_token(token_value* tok, FILE* file, int print_enum);$/;"	p	signature:(token_value* tok, FILE* file, int print_enum)
print_token_to_str	lexer.c	/^int print_token_to_str(token_value* tok, char* buf, size_t size)$/;"	f	signature:(token_value* tok, char* buf, size_t size)
print_token_to_str	lexer.h	/^int print_token_to_str(token_value* tok, char* buf, size_t size);$/;"	p	signature:(token_value* tok, char* buf, size_t size)
print_type	parser.c	/^void print_type(var_value* v)$/;"	f	signature:(var_value* v)
print_type	parser.h	/^void print_type(var_value* v);$/;"	p	signature:(var_value* v)
program_state	parser.h	/^typedef struct program_state$/;"	s
program_state	parser.h	/^} program_state;$/;"	t	typeref:struct:program_state
program_state::bindings	parser.h	/^	vector_void* bindings;$/;"	m	struct:program_state	access:public
program_state::cur_iter	parser.h	/^	int cur_iter;$/;"	m	struct:program_state	access:public
program_state::cur_iter_switch	parser.h	/^	int cur_iter_switch;$/;"	m	struct:program_state	access:public
program_state::cur_parent	parser.h	/^	int cur_parent; \/\/<-- location of open block statement$/;"	m	struct:program_state	access:public
program_state::expressions	parser.h	/^	vector_void expressions;$/;"	m	struct:program_state	access:public
program_state::func	parser.h	/^	function* func;$/;"	m	struct:program_state	access:public
program_state::functions	parser.h	/^	vector_void functions;$/;"	m	struct:program_state	access:public
program_state::global_values	parser.h	/^	vector_void global_values;$/;"	m	struct:program_state	access:public
program_state::global_variables	parser.h	/^	vector_str global_variables;$/;"	m	struct:program_state	access:public
program_state::pc	parser.h	/^	size_t* pc;$/;"	m	struct:program_state	access:public
program_state::stmt_list	parser.h	/^	vector_void* stmt_list;$/;"	m	struct:program_state	access:public
program_state::string_db	parser.h	/^	vector_str string_db;$/;"	m	struct:program_state	access:public
ptr	parser.h	/^		unsigned int ptr;$/;"	m	union:var_value::__anon2	access:public
push_d	cvector.h	/^int push_d(vector_d* vec, double a)$/;"	f	signature:(vector_d* vec, double a)
push_d	cvector.h	/^int push_d(vector_d* vec, double a);$/;"	p	signature:(vector_d* vec, double a)
push_i	cvector.h	/^int push_i(vector_i* vec, int a)$/;"	f	signature:(vector_i* vec, int a)
push_i	cvector.h	/^int push_i(vector_i* vec, int a);$/;"	p	signature:(vector_i* vec, int a)
push_str	cvector.h	/^int push_str(vector_str* vec, char* a)$/;"	f	signature:(vector_str* vec, char* a)
push_str	cvector.h	/^int push_str(vector_str* vec, char* a);$/;"	p	signature:(vector_str* vec, char* a)
push_token_lex	vector_token_lex.h	/^int push_token_lex(vector_token_lex* vec, token_lex* a)$/;"	f	signature:(vector_token_lex* vec, token_lex* a)
push_token_lex	vector_token_lex.h	/^int push_token_lex(vector_token_lex* vec, token_lex* val);$/;"	p	signature:(vector_token_lex* vec, token_lex* val)
push_void	cvector.h	/^int push_void(vector_void* vec, void* a)$/;"	f	signature:(vector_void* vec, void* a)
push_void	cvector.h	/^int push_void(vector_void* vec, void* val);$/;"	p	signature:(vector_void* vec, void* val)
rand_double	c_utils.c	/^double rand_double(double min, double max)$/;"	f	signature:(double min, double max)
rand_double	c_utils.h	/^double rand_double(double min, double max);$/;"	p	signature:(double min, double max)
rand_float	c_utils.c	/^float rand_float(float min, float max)$/;"	f	signature:(float min, float max)
rand_float	c_utils.h	/^float rand_float(float min, float max);$/;"	p	signature:(float min, float max)
read_char	c_utils.c	/^int read_char(FILE* input, const char* skip_chars, int complement, int clear_line)$/;"	f	signature:(FILE* input, const char* skip_chars, int complement, int clear_line)
read_char	c_utils.h	/^int read_char(FILE* input, const char* skip_chars, int complement, int clear_line);$/;"	p	signature:(FILE* input, const char* skip_chars, int complement, int clear_line)
read_string	c_utils.c	/^char* read_string(FILE* file, const char* skip_chars, int delim, size_t max_len)$/;"	f	signature:(FILE* file, const char* skip_chars, int delim, size_t max_len)
read_string	c_utils.h	/^char* read_string(FILE* file, const char* skip_chars, int delim, size_t max_len);$/;"	p	signature:(FILE* file, const char* skip_chars, int delim, size_t max_len)
read_token	lexer.c	/^token_lex read_token(FILE* file, lexer_state* lex_state, FILE* preprocessed)$/;"	f	signature:(FILE* file, lexer_state* lex_state, FILE* preprocessed)
read_token	lexer.h	/^token_lex read_token(FILE* file, lexer_state* lex_state, FILE* preprocessed);$/;"	p	signature:(FILE* file, lexer_state* lex_state, FILE* preprocessed)
read_token_from_str	lexer.c	/^token_lex read_token_from_str(char* input, lexer_state* lex_state, FILE* preprocessed)$/;"	f	signature:(char* input, lexer_state* lex_state, FILE* preprocessed)
read_token_from_str	lexer.h	/^token_lex read_token_from_str(char* input, lexer_state* lex_state, FILE* preprocessed);$/;"	p	signature:(char* input, lexer_state* lex_state, FILE* preprocessed)
readline	c_utils.c	/^char* readline(c_array* input)$/;"	f	signature:(c_array* input)
readline	c_utils.h	/^char* readline(c_array* input);$/;"	p	signature:(c_array* input)
readline_into_str	c_utils.c	/^int readline_into_str(c_array* input, char* str, size_t len)$/;"	f	signature:(c_array* input, char* str, size_t len)
readline_into_str	c_utils.h	/^int readline_into_str(c_array* input, char* str, size_t len);$/;"	p	signature:(c_array* input, char* str, size_t len)
readstring	c_utils.c	/^char* readstring(c_array* input, char delim, size_t max_len)$/;"	f	signature:(c_array* input, char delim, size_t max_len)
readstring	c_utils.h	/^char* readstring(c_array* input, char delim, size_t max_len);$/;"	p	signature:(c_array* input, char delim, size_t max_len)
readstring_into_str	c_utils.c	/^int readstring_into_str(c_array* input, char delim, char* str, size_t len)$/;"	f	signature:(c_array* input, char delim, char* str, size_t len)
readstring_into_str	c_utils.h	/^int readstring_into_str(c_array* input, char delim, char* str, size_t len);$/;"	p	signature:(c_array* input, char delim, char* str, size_t len)
relational_expr	parser.c	/^void relational_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
relational_expr	parser.h	/^void relational_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
remove_binding	interpreter.c	/^void remove_binding(program_state* prog, char* name)$/;"	f	signature:(program_state* prog, char* name)
remove_binding	interpreter.h	/^void remove_binding(program_state* prog, char* name);$/;"	p	signature:(program_state* prog, char* name)
remove_binding	parser.h	/^void remove_binding(program_state* prog, char* name);$/;"	p	signature:(program_state* prog, char* name)
remove_binding_symbol	interpreter.c	/^void remove_binding_symbol(symbol* s)$/;"	f	signature:(symbol* s)
remove_scope	interpreter.c	/^void remove_scope(program_state* prog, int jump_to, int child, int parent)$/;"	f	signature:(program_state* prog, int jump_to, int child, int parent)
remove_scope	interpreter.h	/^void remove_scope(program_state* prog, int jump_to, int child, int parent);$/;"	p	signature:(program_state* prog, int jump_to, int child, int parent)
remove_scope	parser.h	/^void remove_scope(program_state* prog, int jump_to, int child, int parent);$/;"	p	signature:(program_state* prog, int jump_to, int child, int parent)
rescan_expansion	preprocessor.c	/^void rescan_expansion(preprocessor_state* preproc, rsw_cstr* expansion, vector_i* valid_macros, int macro_index)$/;"	f	signature:(preprocessor_state* preproc, rsw_cstr* expansion, vector_i* valid_macros, int macro_index)
rescan_expansion	preprocessor.h	/^void rescan_expansion(preprocessor_state* preproc, rsw_cstr* expansion, vector_i* valid_macros, int macro_index);$/;"	p	signature:(preprocessor_state* preproc, rsw_cstr* expansion, vector_i* valid_macros, int macro_index)
reserve_d	cvector.h	/^int reserve_d(vector_d* vec, size_t size)$/;"	f	signature:(vector_d* vec, size_t size)
reserve_d	cvector.h	/^int reserve_d(vector_d* vec, size_t size);$/;"	p	signature:(vector_d* vec, size_t size)
reserve_i	cvector.h	/^int reserve_i(vector_i* vec, size_t size)$/;"	f	signature:(vector_i* vec, size_t size)
reserve_i	cvector.h	/^int reserve_i(vector_i* vec, size_t size);$/;"	p	signature:(vector_i* vec, size_t size)
reserve_str	cvector.h	/^int reserve_str(vector_str* vec, size_t size)$/;"	f	signature:(vector_str* vec, size_t size)
reserve_str	cvector.h	/^int reserve_str(vector_str* vec, size_t size);$/;"	p	signature:(vector_str* vec, size_t size)
reserve_token_lex	vector_token_lex.h	/^int reserve_token_lex(vector_token_lex* vec, size_t size)$/;"	f	signature:(vector_token_lex* vec, size_t size)
reserve_token_lex	vector_token_lex.h	/^int reserve_token_lex(vector_token_lex* vec, size_t size);$/;"	p	signature:(vector_token_lex* vec, size_t size)
reserve_void	cvector.h	/^int reserve_void(vector_void* vec, size_t size)$/;"	f	signature:(vector_void* vec, size_t size)
reserve_void	cvector.h	/^int reserve_void(vector_void* vec, size_t size);$/;"	p	signature:(vector_void* vec, size_t size)
ret_val	parser.h	/^	var_value ret_val;$/;"	m	struct:function	access:public
return_stmt	parser.c	/^void return_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
return_stmt	parser.h	/^void return_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
right	parser.h	/^	expression* right;$/;"	m	struct:expression	access:public
rsw_cstr	rsw_cstr.h	/^typedef struct rsw_cstr$/;"	s
rsw_cstr	rsw_cstr.h	/^} rsw_cstr;$/;"	t	typeref:struct:rsw_cstr
rsw_cstr::a	rsw_cstr.h	/^	char* a;           \/**< Array. *\/$/;"	m	struct:rsw_cstr	access:public
rsw_cstr::capacity	rsw_cstr.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size + 1 (for '\\0'). *\/$/;"	m	struct:rsw_cstr	access:public
rsw_cstr::size	rsw_cstr.h	/^	size_t size;       \/**< current size, ie what strlen() would return or std::string::size() *\/$/;"	m	struct:rsw_cstr	access:public
rtrim	c_utils.c	/^char* rtrim(char* str)$/;"	f	signature:(char* str)
rtrim	c_utils.h	/^char* rtrim(char* str);$/;"	p	signature:(char* str)
run	interpreter.c	/^void run(program_state* prog, char* start_func)$/;"	f	signature:(program_state* prog, char* start_func)
run	interpreter.h	/^void run(program_state* prog, char* start_func);$/;"	p	signature:(program_state* prog, char* start_func)
run_preprocessor	preprocessor.c	/^FILE* run_preprocessor(FILE* input, char* filename)$/;"	f	signature:(FILE* input, char* filename)
run_preprocessor	preprocessor.h	/^FILE* run_preprocessor(FILE* input, char* filename);$/;"	p	signature:(FILE* input, char* filename)
schar_val	parser.h	/^		signed char schar_val; \/\/ <- because plain char can be signed or unsigned$/;"	m	union:var_value::__anon2	access:public
set_capacity_d	cvector.h	/^int set_capacity_d(vector_d* vec, size_t size)$/;"	f	signature:(vector_d* vec, size_t size)
set_capacity_d	cvector.h	/^int set_capacity_d(vector_d* vec, size_t size);$/;"	p	signature:(vector_d* vec, size_t size)
set_capacity_i	cvector.h	/^int set_capacity_i(vector_i* vec, size_t size)$/;"	f	signature:(vector_i* vec, size_t size)
set_capacity_i	cvector.h	/^int set_capacity_i(vector_i* vec, size_t size);$/;"	p	signature:(vector_i* vec, size_t size)
set_capacity_str	cvector.h	/^int set_capacity_str(vector_str* vec, size_t size)$/;"	f	signature:(vector_str* vec, size_t size)
set_capacity_str	cvector.h	/^int set_capacity_str(vector_str* vec, size_t size);$/;"	p	signature:(vector_str* vec, size_t size)
set_capacity_token_lex	vector_token_lex.h	/^int set_capacity_token_lex(vector_token_lex* vec, size_t size)$/;"	f	signature:(vector_token_lex* vec, size_t size)
set_capacity_token_lex	vector_token_lex.h	/^int set_capacity_token_lex(vector_token_lex* vec, size_t size);$/;"	p	signature:(vector_token_lex* vec, size_t size)
set_capacity_void	cvector.h	/^int set_capacity_void(vector_void* vec, size_t size)$/;"	f	signature:(vector_void* vec, size_t size)
set_capacity_void	cvector.h	/^int set_capacity_void(vector_void* vec, size_t size);$/;"	p	signature:(vector_void* vec, size_t size)
set_val_cap_d	cvector.h	/^void set_val_cap_d(vector_d* vec, double val)$/;"	f	signature:(vector_d* vec, double val)
set_val_cap_d	cvector.h	/^void set_val_cap_d(vector_d* vec, double val);$/;"	p	signature:(vector_d* vec, double val)
set_val_cap_i	cvector.h	/^void set_val_cap_i(vector_i* vec, int val)$/;"	f	signature:(vector_i* vec, int val)
set_val_cap_i	cvector.h	/^void set_val_cap_i(vector_i* vec, int val);$/;"	p	signature:(vector_i* vec, int val)
set_val_cap_str	cvector.h	/^void set_val_cap_str(vector_str* vec, char* val)$/;"	f	signature:(vector_str* vec, char* val)
set_val_cap_str	cvector.h	/^void set_val_cap_str(vector_str* vec, char* val);$/;"	p	signature:(vector_str* vec, char* val)
set_val_cap_token_lex	vector_token_lex.h	/^void set_val_cap_token_lex(vector_token_lex* vec, token_lex* val)$/;"	f	signature:(vector_token_lex* vec, token_lex* val)
set_val_cap_token_lex	vector_token_lex.h	/^void set_val_cap_token_lex(vector_token_lex* vec, token_lex* val);$/;"	p	signature:(vector_token_lex* vec, token_lex* val)
set_val_cap_void	cvector.h	/^void set_val_cap_void(vector_void* vec, void* val)$/;"	f	signature:(vector_void* vec, void* val)
set_val_cap_void	cvector.h	/^void set_val_cap_void(vector_void* vec, void* val);$/;"	p	signature:(vector_void* vec, void* val)
set_val_sz_d	cvector.h	/^void set_val_sz_d(vector_d* vec, double val)$/;"	f	signature:(vector_d* vec, double val)
set_val_sz_d	cvector.h	/^void set_val_sz_d(vector_d* vec, double val);$/;"	p	signature:(vector_d* vec, double val)
set_val_sz_i	cvector.h	/^void set_val_sz_i(vector_i* vec, int val)$/;"	f	signature:(vector_i* vec, int val)
set_val_sz_i	cvector.h	/^void set_val_sz_i(vector_i* vec, int val);$/;"	p	signature:(vector_i* vec, int val)
set_val_sz_str	cvector.h	/^void set_val_sz_str(vector_str* vec, char* val)$/;"	f	signature:(vector_str* vec, char* val)
set_val_sz_str	cvector.h	/^void set_val_sz_str(vector_str* vec, char* val);$/;"	p	signature:(vector_str* vec, char* val)
set_val_sz_token_lex	vector_token_lex.h	/^void set_val_sz_token_lex(vector_token_lex* vec, token_lex* val)$/;"	f	signature:(vector_token_lex* vec, token_lex* val)
set_val_sz_token_lex	vector_token_lex.h	/^void set_val_sz_token_lex(vector_token_lex* vec, token_lex* val);$/;"	p	signature:(vector_token_lex* vec, token_lex* val)
set_val_sz_void	cvector.h	/^void set_val_sz_void(vector_void* vec, void* val)$/;"	f	signature:(vector_void* vec, void* val)
set_val_sz_void	cvector.h	/^void set_val_sz_void(vector_void* vec, void* val);$/;"	p	signature:(vector_void* vec, void* val)
shift_expr	parser.c	/^void shift_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
shift_expr	parser.h	/^void shift_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
short_val	parser.h	/^		short short_val;$/;"	m	union:var_value::__anon2	access:public
size	cvector.h	/^	size_t size;             \/**< Current size (amount you should use when manipulating array directly). *\/$/;"	m	struct:vector_void	access:public
size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_d	access:public
size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_i	access:public
size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_str	access:public
size	rsw_cstr.h	/^	size_t size;       \/**< current size, ie what strlen() would return or std::string::size() *\/$/;"	m	struct:rsw_cstr	access:public
size	vector_token_lex.h	/^	size_t size;$/;"	m	struct:vector_token_lex	access:public
slice_c_array	c_utils.c	/^c_array slice_c_array(c_array array, long start, long end)$/;"	f	signature:(c_array array, long start, long end)
slice_c_array	c_utils.h	/^c_array slice_c_array(c_array array, long start, long end);$/;"	p	signature:(c_array array, long start, long end)
slice_cstr	rsw_cstr.c	/^rsw_cstr slice_cstr(rsw_cstr* str, long start, long end)$/;"	f	signature:(rsw_cstr* str, long start, long end)
slice_cstr	rsw_cstr.h	/^rsw_cstr slice_cstr(rsw_cstr* str, long start, long end);$/;"	p	signature:(rsw_cstr* str, long start, long end)
sort_list	clist.h	/^void sort_list(list_head* head, int cmp(list_head*, list_head*))$/;"	f	signature:(list_head* head, int cmp(list_head*, list_head*))
sort_list	clist.h	/^void sort_list(list_head* head, int cmp(list_head*, list_head*));$/;"	p	signature:(list_head* head, int cmp(list_head*, list_head*))
split	c_utils.c	/^int split(c_array* array, byte* delim, size_t delim_len, c_array* out)$/;"	f	signature:(c_array* array, byte* delim, size_t delim_len, c_array* out)
split	c_utils.h	/^int split(c_array* in, byte* delim, size_t delim_len, c_array* out);$/;"	p	signature:(c_array* in, byte* delim, size_t delim_len, c_array* out)
statement	parser.h	/^typedef struct statement$/;"	s
statement	parser.h	/^} statement;$/;"	t	typeref:struct:statement
statement::bindings	parser.h	/^	vector_void* bindings;$/;"	m	struct:statement	access:public
statement::case_val	parser.h	/^	int case_val;$/;"	m	struct:statement	access:public
statement::exp	parser.h	/^	expression* exp;$/;"	m	struct:statement	access:public
statement::jump_to	parser.h	/^	size_t jump_to;$/;"	m	struct:statement	access:public
statement::lvalue	parser.h	/^	char* lvalue;$/;"	m	struct:statement	access:public
statement::parent	parser.h	/^	long parent;$/;"	m	struct:statement	access:public
statement::type	parser.h	/^	stmt_type type;$/;"	m	struct:statement	access:public
statement::vtype	parser.h	/^	var_type vtype;$/;"	m	struct:statement	access:public
statement_rule	parser.c	/^void statement_rule(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
statement_rule	parser.h	/^void statement_rule(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
stmt_list	parser.h	/^	vector_void stmt_list;$/;"	m	struct:function	access:public
stmt_list	parser.h	/^	vector_void* stmt_list;$/;"	m	struct:program_state	access:public
stmt_type	parser.h	/^} stmt_type;$/;"	t	typeref:enum:__anon3
string_db	parser.h	/^	vector_str string_db;$/;"	m	struct:program_state	access:public
switch_stmt	parser.c	/^void switch_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
switch_stmt	parser.h	/^void switch_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
symbol	parser.h	/^typedef struct symbol$/;"	s
symbol	parser.h	/^} symbol;$/;"	t	typeref:struct:symbol
symbol::cur_parent	parser.h	/^	int cur_parent;$/;"	m	struct:symbol	access:public
symbol::head	parser.h	/^	list_head head;$/;"	m	struct:symbol	access:public
symbol::name	parser.h	/^	char* name;$/;"	m	struct:symbol	access:public
symbols	parser.h	/^	vector_void symbols;$/;"	m	struct:function	access:public
tok	lexer.h	/^	token_value tok;$/;"	m	struct:token_lex	access:public
tok	parser.h	/^	token_value tok;$/;"	m	struct:expression	access:public
token_lex	lexer.h	/^typedef struct token_lex$/;"	s
token_lex	lexer.h	/^} token_lex;$/;"	t	typeref:struct:token_lex
token_lex::char_pos	lexer.h	/^	char* char_pos; \/\/location in overall file string (only used in read_token_from_str)$/;"	m	struct:token_lex	access:public
token_lex::line	lexer.h	/^	unsigned int line;$/;"	m	struct:token_lex	access:public
token_lex::pos	lexer.h	/^	unsigned int pos; \/\/pos on line$/;"	m	struct:token_lex	access:public
token_lex::tok	lexer.h	/^	token_value tok;$/;"	m	struct:token_lex	access:public
token_value	lexer.h	/^typedef struct token_value$/;"	s
token_value	lexer.h	/^} token_value;$/;"	t	typeref:struct:token_value
token_value::__anon5::double_val	lexer.h	/^		double double_val;$/;"	m	union:token_value::__anon5	access:public
token_value::__anon5::float_val	lexer.h	/^		float float_val;$/;"	m	union:token_value::__anon5	access:public
token_value::__anon5::id	lexer.h	/^		char* id;$/;"	m	union:token_value::__anon5	access:public
token_value::__anon5::int_val	lexer.h	/^		int int_val;$/;"	m	union:token_value::__anon5	access:public
token_value::type	lexer.h	/^	Token type;$/;"	m	struct:token_value	access:public
token_value::v	lexer.h	/^	} v;$/;"	m	struct:token_value	typeref:union:token_value::__anon5	access:public
tokens	parser.h	/^	vector_token_lex tokens;$/;"	m	struct:parsing_state	access:public
top_level_declaration	parser.c	/^void top_level_declaration(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
top_level_declaration	parser.h	/^void top_level_declaration(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
translation_unit	parser.c	/^void translation_unit(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
translation_unit	parser.h	/^void translation_unit(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
trim	c_utils.c	/^char* trim(char* str)$/;"	f	signature:(char* str)
trim	c_utils.h	/^char* trim(char* str);$/;"	p	signature:(char* str)
type	lexer.h	/^	Token type;$/;"	m	struct:token_value	access:public
type	parser.h	/^	stmt_type type;$/;"	m	struct:statement	access:public
type	parser.h	/^	var_type type;$/;"	m	struct:var_value	access:public
u8	cvector.h	/^typedef unsigned char u8;$/;"	t
uchar_val	parser.h	/^		unsigned char uchar_val;$/;"	m	union:var_value::__anon2	access:public
uint_val	parser.h	/^		unsigned int uint_val;$/;"	m	union:var_value::__anon2	access:public
ulong_val	parser.h	/^		unsigned long ulong_val;$/;"	m	union:var_value::__anon2	access:public
unary_expr	parser.c	/^void unary_expr(parsing_state* p, program_state* prog, expression* e)$/;"	f	signature:(parsing_state* p, program_state* prog, expression* e)
unary_expr	parser.h	/^void unary_expr(parsing_state* p, program_state* prog, expression* e);$/;"	p	signature:(parsing_state* p, program_state* prog, expression* e)
used	parser.h	/^	size_t used;$/;"	m	struct:expr_block	access:public
ushort_val	parser.h	/^		unsigned short ushort_val;$/;"	m	union:var_value::__anon2	access:public
v	lexer.h	/^	} v;$/;"	m	struct:token_value	typeref:union:token_value::__anon5	access:public
v	parser.h	/^	} v;$/;"	m	struct:var_value	typeref:union:var_value::__anon2	access:public
val	parser.h	/^	int val;$/;"	m	struct:a_case	access:public
val	parser.h	/^	var_value val;$/;"	m	struct:active_binding	access:public
values	preprocessor.h	/^	vector_str values;$/;"	m	struct:preprocessor_state	access:public
var_type	parser.h	/^} var_type;$/;"	t	typeref:enum:__anon1
var_value	parser.h	/^typedef struct var_value$/;"	s
var_value	parser.h	/^} var_value;$/;"	t	typeref:struct:var_value
var_value::__anon2::char_val	parser.h	/^		char char_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::double_val	parser.h	/^		double double_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::float_val	parser.h	/^		float float_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::func_loc	parser.h	/^		unsigned int func_loc; \/\/change to direct pointer?$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::int_val	parser.h	/^		int int_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::long_val	parser.h	/^		long long_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::ptr	parser.h	/^		unsigned int ptr;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::schar_val	parser.h	/^		signed char schar_val; \/\/ <- because plain char can be signed or unsigned$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::short_val	parser.h	/^		short short_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::uchar_val	parser.h	/^		unsigned char uchar_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::uint_val	parser.h	/^		unsigned int uint_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::ulong_val	parser.h	/^		unsigned long ulong_val;$/;"	m	union:var_value::__anon2	access:public
var_value::__anon2::ushort_val	parser.h	/^		unsigned short ushort_val;$/;"	m	union:var_value::__anon2	access:public
var_value::type	parser.h	/^	var_type type;$/;"	m	struct:var_value	access:public
var_value::v	parser.h	/^	} v;$/;"	m	struct:var_value	typeref:union:var_value::__anon2	access:public
vec_d	cvector.h	/^int vec_d(vector_d* vec, size_t size, size_t capacity)$/;"	f	signature:(vector_d* vec, size_t size, size_t capacity)
vec_d	cvector.h	/^int vec_d(vector_d* vec, size_t size, size_t capacity);$/;"	p	signature:(vector_d* vec, size_t size, size_t capacity)
vec_d_copy	cvector.h	/^void vec_d_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_d_copy	cvector.h	/^void vec_d_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_d_heap	cvector.h	/^vector_d* vec_d_heap(size_t size, size_t capacity)$/;"	f	signature:(size_t size, size_t capacity)
vec_d_heap	cvector.h	/^vector_d* vec_d_heap(size_t size, size_t capacity);$/;"	p	signature:(size_t size, size_t capacity)
vec_i	cvector.h	/^int vec_i(vector_i* vec, size_t size, size_t capacity)$/;"	f	signature:(vector_i* vec, size_t size, size_t capacity)
vec_i	cvector.h	/^int vec_i(vector_i* vec, size_t size, size_t capacity);$/;"	p	signature:(vector_i* vec, size_t size, size_t capacity)
vec_i_copy	cvector.h	/^void vec_i_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_i_copy	cvector.h	/^void vec_i_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_i_heap	cvector.h	/^vector_i* vec_i_heap(size_t size, size_t capacity)$/;"	f	signature:(size_t size, size_t capacity)
vec_i_heap	cvector.h	/^vector_i* vec_i_heap(size_t size, size_t capacity);$/;"	p	signature:(size_t size, size_t capacity)
vec_str	cvector.h	/^int vec_str(vector_str* vec, size_t size, size_t capacity)$/;"	f	signature:(vector_str* vec, size_t size, size_t capacity)
vec_str	cvector.h	/^int vec_str(vector_str* vec, size_t size, size_t capacity);$/;"	p	signature:(vector_str* vec, size_t size, size_t capacity)
vec_str_copy	cvector.h	/^void vec_str_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_str_copy	cvector.h	/^void vec_str_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_str_heap	cvector.h	/^vector_str* vec_str_heap(size_t size, size_t capacity)$/;"	f	signature:(size_t size, size_t capacity)
vec_str_heap	cvector.h	/^vector_str* vec_str_heap(size_t size, size_t capacity);$/;"	p	signature:(size_t size, size_t capacity)
vec_token_lex	vector_token_lex.h	/^int vec_token_lex(vector_token_lex* vec, size_t size, size_t capacity, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(vector_token_lex* vec, size_t size, size_t capacity, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vec_token_lex	vector_token_lex.h	/^int vec_token_lex(vector_token_lex* vec, size_t size, size_t capacity, void(*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(vector_token_lex* vec, size_t size, size_t capacity, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vec_token_lex_copy	vector_token_lex.h	/^void vec_token_lex_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_token_lex_copy	vector_token_lex.h	/^void vec_token_lex_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_token_lex_heap	vector_token_lex.h	/^vector_token_lex* vec_token_lex_heap(size_t size, size_t capacity, void (*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(size_t size, size_t capacity, void (*elem_free)(void*), void(*elem_init)(void*, void*))
vec_token_lex_heap	vector_token_lex.h	/^vector_token_lex* vec_token_lex_heap(size_t size, size_t capacity, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(size_t size, size_t capacity, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vec_void	cvector.h	/^int vec_void(vector_void* vec, size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(vector_void* vec, size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vec_void	cvector.h	/^int vec_void(vector_void* vec, size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(vector_void* vec, size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vec_void_copy	cvector.h	/^void vec_void_copy(void* dest, void* src)$/;"	f	signature:(void* dest, void* src)
vec_void_copy	cvector.h	/^void vec_void_copy(void* dest, void* src);$/;"	p	signature:(void* dest, void* src)
vec_void_get	cvector.h	/^void* vec_void_get(vector_void* vec, size_t i)$/;"	f	signature:(vector_void* vec, size_t i)
vec_void_get	cvector.h	/^void* vec_void_get(vector_void* vec, size_t i);$/;"	p	signature:(vector_void* vec, size_t i)
vec_void_heap	cvector.h	/^vector_void* vec_void_heap(size_t size, size_t capacity, size_t elem_sz, void (*elem_free)(void*), void(*elem_init)(void*, void*));$/;"	p	signature:(size_t size, size_t capacity, size_t elem_sz, void (*elem_free)(void*), void(*elem_init)(void*, void*))
vec_void_heap	cvector.h	/^vector_void* vec_void_heap(size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))$/;"	f	signature:(size_t size, size_t capacity, size_t elem_sz, void(*elem_free)(void*), void(*elem_init)(void*, void*))
vector_d	cvector.h	/^typedef struct vector_d$/;"	s
vector_d	cvector.h	/^} vector_d;$/;"	t	typeref:struct:vector_d
vector_d::a	cvector.h	/^	double* a;         \/**< Array. *\/$/;"	m	struct:vector_d	access:public
vector_d::capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_d	access:public
vector_d::size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_d	access:public
vector_i	cvector.h	/^typedef struct vector_i$/;"	s
vector_i	cvector.h	/^} vector_i;$/;"	t	typeref:struct:vector_i
vector_i::a	cvector.h	/^	int* a;            \/**< Array. *\/$/;"	m	struct:vector_i	access:public
vector_i::capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_i	access:public
vector_i::size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_i	access:public
vector_str	cvector.h	/^typedef struct vector_str$/;"	s
vector_str	cvector.h	/^} vector_str;$/;"	t	typeref:struct:vector_str
vector_str::a	cvector.h	/^	char** a;          \/**< Array. *\/$/;"	m	struct:vector_str	access:public
vector_str::capacity	cvector.h	/^	size_t capacity;   \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_str	access:public
vector_str::size	cvector.h	/^	size_t size;       \/**< Current size (amount you use when manipulating array directly). *\/$/;"	m	struct:vector_str	access:public
vector_token_lex	vector_token_lex.h	/^typedef struct vector_token_lex$/;"	s
vector_token_lex	vector_token_lex.h	/^} vector_token_lex;$/;"	t	typeref:struct:vector_token_lex
vector_token_lex::a	vector_token_lex.h	/^	token_lex* a;$/;"	m	struct:vector_token_lex	access:public
vector_token_lex::capacity	vector_token_lex.h	/^	size_t capacity;$/;"	m	struct:vector_token_lex	access:public
vector_token_lex::elem_free	vector_token_lex.h	/^	void (*elem_free)(void*);$/;"	m	struct:vector_token_lex	access:public
vector_token_lex::elem_init	vector_token_lex.h	/^	void (*elem_init)(void*, void*);$/;"	m	struct:vector_token_lex	access:public
vector_token_lex::size	vector_token_lex.h	/^	size_t size;$/;"	m	struct:vector_token_lex	access:public
vector_void	cvector.h	/^typedef struct vector_void$/;"	s
vector_void	cvector.h	/^} vector_void;$/;"	t	typeref:struct:vector_void
vector_void::a	cvector.h	/^	u8* a;                 \/**< Array. *\/$/;"	m	struct:vector_void	access:public
vector_void::capacity	cvector.h	/^	size_t capacity;         \/**< Allocated size of array; always >= size. *\/$/;"	m	struct:vector_void	access:public
vector_void::elem_free	cvector.h	/^	void (*elem_free)(void*);$/;"	m	struct:vector_void	access:public
vector_void::elem_init	cvector.h	/^	void (*elem_init)(void*, void*);$/;"	m	struct:vector_void	access:public
vector_void::elem_size	cvector.h	/^	size_t elem_size;        \/**< Size in u8s of type stored (sizeof(T) where T is type). *\/$/;"	m	struct:vector_void	access:public
vector_void::size	cvector.h	/^	size_t size;             \/**< Current size (amount you should use when manipulating array directly). *\/$/;"	m	struct:vector_void	access:public
vtype	parser.h	/^	var_type vtype;$/;"	m	struct:binding	access:public
vtype	parser.h	/^	var_type vtype;$/;"	m	struct:statement	access:public
while_stmt	parser.c	/^void while_stmt(parsing_state* p, program_state* prog)$/;"	f	signature:(parsing_state* p, program_state* prog)
while_stmt	parser.h	/^void while_stmt(parsing_state* p, program_state* prog);$/;"	p	signature:(parsing_state* p, program_state* prog)
